import{e as f,r as k,o as T,c as j,a as b,b as n,w as r,i as g,h as l,v as o,T as i,F as h,f as v,p as S,d as y}from"./index-2e4f8d1f.js";import{_ as q}from"./_plugin-vue_export-helper-c27b6911.js";const t=d=>(S("data-v-97bbe293"),d=d(),y(),d),C={class:"leftNav"},N={class:"leftNavContainer"},x={class:"leftNavLayout"},O=t(()=>b("br",null,null,-1)),J={class:"Main"},L={class:"mainContainer"},V={class:"mainLayout"},P=v('<div class="articleCardTitle cor36" data-v-97bbe293>[ JS ] ≫ 延遲加載JS方式?</div><p data-v-97bbe293>正常: 解析HTML &gt; 遇到JS &gt; 下載 &gt; 執行 &gt; 繼續解析HTML</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>defer 属性</p><p data-v-97bbe293>解析HTML &gt; 遇到JS &gt; 下載 &gt; 等到 HTML 解析完 &gt; 再執行JS defer</p><p data-v-97bbe293>順次執行 &gt; a.js &gt; b.js</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>async 属性</p><p data-v-97bbe293> 解析HTML &gt; 遇到async &gt; 下載並同時解析 HTML &gt; async加載完 HTML暫停 直接執行JS &gt; 再繼續解析 HTML </p><p data-v-97bbe293>和HTML解析同步</p><p data-v-97bbe293>不是順次執行 誰先加載完 誰執行</p><br data-v-97bbe293><br data-v-97bbe293><div id="" class="articleCardTitle cor36" data-v-97bbe293>[ JS ] ≫ ES6 新特性?</div><p data-v-97bbe293>let . const . map . set . 箭頭函數 . 解構復值 . promise</p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs001" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ JS數據類型? </div><p data-v-97bbe293>幾本類型:</p><p class="pFou" data-v-97bbe293>string number 布林 null undefined symbol bigInt</p><br data-v-97bbe293><p data-v-97bbe293>引用類型:</p><p class="pFou" data-v-97bbe293>object</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293># 陣列,函數,日期屬於數據類型嗎?</p><p data-v-97bbe293>不屬於, 他們屬於構造函數</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>函數屬於哪個? _ object</p><p data-v-97bbe293>陣列屬於哪個? _ object</p><p data-v-97bbe293>正則屬於哪個? _ object</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293># 為什麼不用大寫STRING?</p><p data-v-97bbe293> 因為小寫string上面有大寫STRING的方法, 大寫STRING是小寫string的封裝類型 在小寫屬性.方法會自動封裝成大寫STRING, 然後用完之後自動銷毀 </p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293># 值和地址區別?</p><p data-v-97bbe293>string nember 布林都是值, 如果存一個object對象到一個變量是地址</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293># 哪我存一個函數到一個變量?</p><p data-v-97bbe293>存到地址</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293> # 存一個變量怎麼知道他存在值還是地址,根據他麼什麼的能區分? </p><p data-v-97bbe293>用typeof看一下, typeof object &amp; function 是地址</p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs002" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ null undefined區別? </div><p data-v-97bbe293>1.undefined是聲明之後的默認值, 但null不是</p><p data-v-97bbe293> 2.undefined一般給基本類型做未賦值, null一般給物件(物件,陣列,函數為空)做未賦值 </p><p data-v-97bbe293>3.undefined不是關鍵字, null是關鍵字, 所以不能聲明一個變量叫null</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293># 如果我聲明一個變量它的值?</p><p data-v-97bbe293>undefined</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293># NaN類型?</p><p data-v-97bbe293>Number</p><br data-v-97bbe293><p data-v-97bbe293>因為 NaN 表示一個不能表示的數字</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293># typeof null?</p><p data-v-97bbe293>object</p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs003" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ ==和===有什麼不同? </div><p class="cor36" data-v-97bbe293>寬鬆相等 ==</p><p data-v-97bbe293> 當等號兩邊的值為相同類型時比較值是否相同，類型不同時會發生類型的自動轉換，轉換為相同的類型後再做比較。 </p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>嚴格相等 ===</p><p data-v-97bbe293> 當等號兩邊的值為相同類型時，直接比較等號兩邊的值，相同返回 true；若等號兩邊值的類型不同時直接返回 false。 </p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>1. NaN 和其他任何類型比較永遠返回 false。</p><br data-v-97bbe293><p data-v-97bbe293> 2. Boolean 和其他任何類型比較，Boolean 首先被轉換為 Number 類型。 </p><br data-v-97bbe293><p data-v-97bbe293>3. String 和 Number 比較，先將 String 轉換為 Number 類型。</p><br data-v-97bbe293><p data-v-97bbe293> 4. null == undefined 比較結果是 true，除此之外，null、undefined 和其他任何結果的比較值都為 false。 </p><br data-v-97bbe293><p data-v-97bbe293> 5. 原始類型和引用類型做比較時，引用類型會依照 ToPrimitive 規則轉換為原始類型。 </p><br data-v-97bbe293><p data-v-97bbe293>6. 兩個都為引用類型，則比較它們是否指向同一個物件。</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>1 == &quot;1&quot; . . . // true</p><br data-v-97bbe293><p data-v-97bbe293>1 === &quot;1&quot; . . . // false</p><br data-v-97bbe293><p data-v-97bbe293>NaN == NaN . . . // false</p><br data-v-97bbe293><p data-v-97bbe293>true == 1 . . . // true</p><br data-v-97bbe293><p data-v-97bbe293>true == &#39;2&#39; . . . // false, 先把 true 變 1，再參考規則 3</p><br data-v-97bbe293><p data-v-97bbe293> true == [&#39;1&#39;] . . . // true, 先把 true 變 1， [&#39;1&#39;]拆箱成 &#39;1&#39;, 再參考規則 3 </p><br data-v-97bbe293><p data-v-97bbe293>true == [&#39;2&#39;] . . . // false, 同上</p><br data-v-97bbe293><p data-v-97bbe293> undefined == false . . . // false ，首先 false 變 0，然後參考規則 4 </p><br data-v-97bbe293><p data-v-97bbe293>null == false . . . // false，同上</p><br data-v-97bbe293><p data-v-97bbe293>null == undefined . . . //true</p><br data-v-97bbe293><p data-v-97bbe293>[1,2] == &quot;1,2&quot; . . . //true</p><br data-v-97bbe293><p data-v-97bbe293>123 == &#39;123&#39; . . . // true, &#39;123&#39; 先變 123</p><br data-v-97bbe293><p data-v-97bbe293>&quot;&quot; == 0 . . . // true, &quot;&quot; 先變 0</p><br data-v-97bbe293><p data-v-97bbe293>&quot; &quot; == 0 . . . // true, &quot; &quot; 先變 0</p><br data-v-97bbe293><p data-v-97bbe293>+0 == -0 . . . // true</p><br data-v-97bbe293><p data-v-97bbe293>null == undefined . . . // true</p><br data-v-97bbe293><p data-v-97bbe293>null == &quot;&quot; . . . // false</p><br data-v-97bbe293><p data-v-97bbe293>null == 0 . . . // false</p><br data-v-97bbe293><p data-v-97bbe293>null == false . . . // false</p><br data-v-97bbe293><p data-v-97bbe293>undefined == &quot;&quot; . . . // false</p><br data-v-97bbe293><p data-v-97bbe293>undefined == 0 . . . // false</p><br data-v-97bbe293><p data-v-97bbe293>undefined == false . . . // false</p><br data-v-97bbe293><p data-v-97bbe293>&quot;false&quot; == false . . . // false // false 轉成 0</p><br data-v-97bbe293><p data-v-97bbe293>NaN == false . . . // false</p><br data-v-97bbe293><p data-v-97bbe293>NaN === false . . . // false</p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs004" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ 0.1+0.2為什麼不等於0.3? </div><p data-v-97bbe293>浮點數運算可能導致精度丟失，因為計算時使用的是二進制表示</p><br data-v-97bbe293><p data-v-97bbe293> 浮點數的精度問題, 0.1在內存裡不一定等於0.1, 0.2在內存裡不一定等於0.2, 結果約等於0.3 </p><br data-v-97bbe293><p data-v-97bbe293>0.1 的二進制 可用 0.1.toString( 2 )</p><br data-v-97bbe293><p data-v-97bbe293>發現是 0. 000 11 0011 0011 0011 0011 0011 ...</p><br data-v-97bbe293><p data-v-97bbe293>number 類型 用 IEEE754 標準 64 位 存儲</p><br data-v-97bbe293><p data-v-97bbe293>小數佔位 52 位</p><br data-v-97bbe293><p data-v-97bbe293>又因為 53 位為 1 , 所以擷取往前進 1 位再保存</p><br data-v-97bbe293><p data-v-97bbe293>發生精度丟失</p><br data-v-97bbe293><p data-v-97bbe293>所以 0.1 再 2 進制後 比 0.1 大</p><br data-v-97bbe293><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>怎麼對比兩個小數大小是否相等?</p><p data-v-97bbe293> 假如a是一個小數, b是一個小數, a去減b的絕對值, 如果減出來的值小於 0.0001 就說明a和b幾乎相等 </p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs027" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ 判斷數字是小數? 小數點後幾位? </div><p data-v-97bbe293>數字裡 是否有 小數點</p><br data-v-97bbe293><p data-v-97bbe293>數字 用 .toString 轉成字串</p><br data-v-97bbe293><p data-v-97bbe293>字串 用 indexOf 拿到小數點在字串的 索引位置</p><br data-v-97bbe293><p data-v-97bbe293>沒 小數點 indexOf 返回 -1</p><br data-v-97bbe293><br data-v-97bbe293><p class="coe36" data-v-97bbe293># 小數點後幾位?</p><p data-v-97bbe293>split 方法可以把字串 切成 數組</p><br data-v-97bbe293><p data-v-97bbe293>把 小數點 做為 隔板 , 把字串 通過 split 方法 切割為一個 數組</p><br data-v-97bbe293><p data-v-97bbe293>數組 第 2 個元素 為 小數點後的部分</p><br data-v-97bbe293><p data-v-97bbe293>取 arr[1] , 然後 .length 方法 獲取長度 , 得到小數點後的個數</p><br data-v-97bbe293><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>x.toString().split(&quot;.&quot;)[1].length</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>1.00 出問題 toString 後只剩 有效位</p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs024" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ 判斷變量是否為陣列? </div><p data-v-97bbe293>1. Array.isArray(變量) 方法</p><p data-v-97bbe293>只需要傳入變量 , 是數組 , 這方法返回 true</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>2. Object.prototype.toString.call() 方法</p><p data-v-97bbe293>他會 返回 一個 字串數組</p><br data-v-97bbe293><p data-v-97bbe293> 判斷 Object.prototype.toString.call(arr) 是否等於 字串 &quot;[object Array]&quot; </p><br data-v-97bbe293><p data-v-97bbe293> 另外 數組本身 toString 被改寫過 , 不能通過數組的 toString 來判斷 </p><br data-v-97bbe293><p data-v-97bbe293>想判斷數據類型要 用 Object 的原型 來實現</p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs028" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ 數組去重? </div><p class="cor36" data-v-97bbe293>1.</p><p data-v-97bbe293>利用 set 結構 不允許 有 重複數據</p><br data-v-97bbe293><p data-v-97bbe293>返回 類 數組 物件 , 所以 new Set 後 要 Array.from 方法轉成數組</p><br data-v-97bbe293><p data-v-97bbe293>Array.from( new Set ( arr ) )</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>2.</p><p data-v-97bbe293>indexOf 從前往後遍歷數組 返回元素 第一次出現 的下標</p><br data-v-97bbe293><p data-v-97bbe293>先 定義 一個 新數組</p><br data-v-97bbe293><p data-v-97bbe293>遍歷 原數組 每次通過 indexOf 方法 , 判斷 當前元素 是否在 新數組</p><br data-v-97bbe293><p data-v-97bbe293>值為 -1 代表 不在新數組 , 就 加入到 新數組 ＜... 就是去重後結果</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>3.</p><p data-v-97bbe293>reduce 傳 2參數 1. 方法(A上一次值,B當前值) 2. 初始值</p><p data-v-97bbe293>循環方式: 每次都是上一次結果 pre</p><p data-v-97bbe293> 比如 第 1 次 1 , 把 1 放到 初始值 [ 1 ] , 第 2 次 [ 1, 2 ] , 每次循環都是上一次結果 </p><p data-v-97bbe293> return 判斷有無重複 , 上次結果 包不包含 當前項目 pre.includes(item) </p><p data-v-97bbe293>包含 ...&gt; 不要 , 直接返回當前數組 , 不包含 ...&gt; 加進 pre</p><p data-v-97bbe293>? pre : [ ...pre , item ]</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>4.</p><p data-v-97bbe293>兩層 for 循環比較</p><p data-v-97bbe293>第 1 層循環選定 1 個值</p><p data-v-97bbe293>第 2 層循環 遍歷 其餘元素</p><p data-v-97bbe293>依次和 這個值 比較</p><p data-v-97bbe293>相同 ..&gt; splice 刪除</p><br data-v-97bbe293><br data-v-97bbe293><div class="cor36" data-v-97bbe293># 方法1: new set</div><div data-v-97bbe293>var arr = [ 1,2,3,2,4,1 ];</div><div data-v-97bbe293>console.log( new Set( arr ) );</div><div data-v-97bbe293>發現打印的是物件</div><div data-v-97bbe293>console.log( Array.from( new Set( arr ) ) );</div><div data-v-97bbe293>打印出陣列</div><div data-v-97bbe293>也可以</div><div data-v-97bbe293>console.log( [...new Set( arr ) ] );</div><br data-v-97bbe293><div data-v-97bbe293>封裝:</div><div data-v-97bbe293>function unique( arr ){</div><div class="pTwo" data-v-97bbe293>return [ Array.from( new Set(arr) ) ]</div><div data-v-97bbe293>}</div><div data-v-97bbe293>console.log( unique( arr ) );</div><br data-v-97bbe293><br data-v-97bbe293><div class="cor36" data-v-97bbe293>#</div><div data-v-97bbe293>function unique( arr ){</div><div class="pTwo" data-v-97bbe293>return [...new Set(arr)]</div><div data-v-97bbe293>}</div><div data-v-97bbe293>console.log( unique( arr ) );</div><br data-v-97bbe293><br data-v-97bbe293><div class="cor36" data-v-97bbe293>方法2: indexOf</div><div data-v-97bbe293> indexOf() 方法會回傳給定元素於陣列中第一個被找到之索引，若不存在於陣列中則回傳 -1 </div><br data-v-97bbe293><div data-v-97bbe293>var arr = [ 1,2,3,2,4,1 ];</div><div data-v-97bbe293>function unique( arr ){</div><div class="pTwo" data-v-97bbe293>var result = [];</div><div class="pTwo" data-v-97bbe293>for( var i = 0 ; i ＜ arr.length ; i++ ){</div><div class="pFou" data-v-97bbe293>if( result.indexOf( arr[i] ) == -1 ){</div><div class="pSix" data-v-97bbe293>result.push( arr[i] );</div><div class="pFou" data-v-97bbe293>}</div><div class="pTwo" data-v-97bbe293>}</div><div class="pTwo" data-v-97bbe293>return result;</div><div data-v-97bbe293>}</div><div data-v-97bbe293>console.log( unique( arr ) );</div><br data-v-97bbe293><div data-v-97bbe293>目標, 遍歷陣列, 看有沒有在 result 陣列, 沒有就添加</div><div data-v-97bbe293>去找 indexOf( arr [ i ] )</div><div data-v-97bbe293> 第一次去找 result 肯定是空的 ( 不存在 ) 就回傳 -1 就把他推進 result 裡面 </div><div data-v-97bbe293>不是 -1 就不動作 完成。</div><br data-v-97bbe293><br data-v-97bbe293><div class="cor36" data-v-97bbe293>方法3: reduce</div><div data-v-97bbe293>var arr = [ 1,2,3,2,4,1 ];</div><div data-v-97bbe293>function unique() {</div><div class="pTwo" data-v-97bbe293>var result = arr.reduce( ( pre , item ) =&gt; {</div><div class="pFou" data-v-97bbe293> return pre.includes ( item ) ? pre : [ ...pre , item ] </div><div class="pTwo" data-v-97bbe293>} , [] )</div><div class="pTwo" data-v-97bbe293>console.log ( result )</div><div data-v-97bbe293>}</div><div data-v-97bbe293>unique()</div><br data-v-97bbe293><div data-v-97bbe293>reduce 傳 2參數 1. 方法(A上一次值,B當前值) 2. 初始值</div><div data-v-97bbe293>循環方式: 每次都是上一次結果 pre</div><div data-v-97bbe293> 比如 第 1 次 1 , 把 1 放到 初始值 [ 1 ] , 第 2 次 [ 1, 2 ] , 每次循環都是上一次結果 </div><div data-v-97bbe293> return 判斷有無重複 , 上次結果 包不包含 當前項目 pre.includes(item) </div><div data-v-97bbe293>包含 ...&gt; 不要 , 直接返回當前數組 , 不包含 ...&gt; 加進 pre</div><div data-v-97bbe293>? pre : [ ...pre , item ]</div><br data-v-97bbe293><br data-v-97bbe293><div class="cor36" data-v-97bbe293>方法4: 兩層 for 循環比較</div><div data-v-97bbe293>var arr = [ 1,2,3,2,4,1 ];</div><div data-v-97bbe293>function unique() {</div><div class="pTwo" data-v-97bbe293>for ( let i = 0 ; i ＜ arr.length ; i++ ) {</div><div class="pFou" data-v-97bbe293>for ( let j = i +1 ; j ＜ arr.length ; j++ ) {</div><div class="pSix" data-v-97bbe293>if ( arr [ i ] === arr [ j ] ) {</div><div class="pEig" data-v-97bbe293>arr.splice ( j, 1 )</div><div class="pEig" data-v-97bbe293>j--</div><div class="pSix" data-v-97bbe293>}</div><div class="pFou" data-v-97bbe293>}</div><div class="pTwo" data-v-97bbe293>}</div><div class="pTwo" data-v-97bbe293>return arr</div><div data-v-97bbe293>}</div><br data-v-97bbe293><br data-v-97bbe293><div data-v-97bbe293>第 1 層循環選定 1 個值</div><div data-v-97bbe293>第 2 層循環 遍歷 其餘元素</div><div data-v-97bbe293>依次和 這個值 比較</div><div data-v-97bbe293>相同 ..&gt; splice 刪除</div><br data-v-97bbe293><br data-v-97bbe293><div id="onejs026" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ 獲得陣列最後一項? </div><p data-v-97bbe293>1. pop()</p><p data-v-97bbe293>刪除陣列最後一個元素 , 並 返回該元素</p><br data-v-97bbe293><p data-v-97bbe293>缺: 會把原陣列 最後一個元素 刪掉</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>2. length</p><p data-v-97bbe293>通過 array.length 得到陣列長度</p><br data-v-97bbe293><p data-v-97bbe293>陣列索引從 0 開始</p><br data-v-97bbe293><p data-v-97bbe293>最後一個元素 的索引 為 length - 1</p><br data-v-97bbe293><p data-v-97bbe293>array 中括號 length - 1 . . . array[length-1]</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>3. slice()</p><p data-v-97bbe293> 通過 指定 起始索引 擷取對應元素 , 返回一個 由 這些元素 組成的 新數組 </p><br data-v-97bbe293><p data-v-97bbe293>當用 負數 做參數 , 會重 陣列 末端開始計數 ,</p><br data-v-97bbe293><p data-v-97bbe293>當 不傳 第 2 個參數時 , 表示一直找到 陣列 末端</p><br data-v-97bbe293><p data-v-97bbe293>arr.slice(-1)</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>4. 陣列 at 方法</p><p data-v-97bbe293>接收 一個 整數 做索引值 , 並返回 索引 對應的 元素</p><br data-v-97bbe293><p data-v-97bbe293>傳 -1 代表 最後一個</p><br data-v-97bbe293><p data-v-97bbe293>arr.at(-1)</p><br data-v-97bbe293><div id="onejs030" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ 數組清空? </div><p class="cor36" data-v-97bbe293>1.直接賦值 空數組</p><p data-v-97bbe293>let a = [ 1,2,3,4 ]</p><p data-v-97bbe293>a = []</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293> 2. splice 方法 -&gt; 會修改原數組 -&gt; 返回值 是 你刪掉的元素 </p><p data-v-97bbe293>arr.splice(起始位置, 需要刪除元素的個數, 插入的值 )</p><br data-v-97bbe293><p data-v-97bbe293>let arr = [ 1,2,3,4 ]</p><p data-v-97bbe293>function fn( arr ) {</p><p class="pTwo" data-v-97bbe293>arr.splice( 0, arr.length )</p><p data-v-97bbe293>}</p><p data-v-97bbe293>fn( arr )</p><p data-v-97bbe293>console.log ( arr )</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>3.修改 length</p><p data-v-97bbe293>let arr = [ 1,2,3,4 ]</p><p data-v-97bbe293>arr.length = 0</p><p data-v-97bbe293>console.log ( arr )</p><div id="onejs023" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ 如何判斷一個物件為空? </div><p data-v-97bbe293>1. JSON.stringify() 方法</p><p data-v-97bbe293>將 json 物件 轉成 json 字串</p><br data-v-97bbe293><p data-v-97bbe293>判斷 序列化後 的物件 是否 等於 字串花括號 &quot;{}&quot;</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>2. Object.keys() 方法</p><p data-v-97bbe293>這方法把 物件中 屬性名 取出來 以數組形式返回</p><br data-v-97bbe293><p data-v-97bbe293>判斷 數組長度 是否為 0 , 為0 &gt; 該物件沒屬性 &gt; 空物件</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>3. for in 遍歷物件</p><p data-v-97bbe293>定義一個函數 , 函數內返回 true</p><br data-v-97bbe293><p data-v-97bbe293>將 for in 循環寫入函數</p><br data-v-97bbe293><p data-v-97bbe293>在循環裡 寫 return false</p><br data-v-97bbe293><p data-v-97bbe293>如果 物件不為空 &gt; 有可遍歷屬性 &gt; 進入循環 &gt; 返回 false</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>4. getOwnPropertyNames</p><br data-v-97bbe293><br data-v-97bbe293><div class="bgcVS" data-v-97bbe293><div data-v-97bbe293><span class="function" data-v-97bbe293>function </span><span class="word" data-v-97bbe293>isEmpty</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>obj</span> <span class="brackets" data-v-97bbe293>){</span></div><div class="padTwo VSL" data-v-97bbe293><span class="then" data-v-97bbe293>return </span><span class="brackets" data-v-97bbe293>JSON</span><span class="variable" data-v-97bbe293>.stringify</span><span class="brackets" data-v-97bbe293>(</span> <span class="word" data-v-97bbe293>obj</span><span class="brackets" data-v-97bbe293>)</span> <span class="then" data-v-97bbe293>===</span><span class="src" data-v-97bbe293>&quot;{}&quot;</span><div data-v-97bbe293></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div><br data-v-97bbe293><br data-v-97bbe293><div data-v-97bbe293><span class="function" data-v-97bbe293>function </span><span class="word" data-v-97bbe293>isEmpty2</span><span class="brackets" data-v-97bbe293>(</span> <span class="word" data-v-97bbe293>obj</span><span class="brackets" data-v-97bbe293>){</span></div><div class="padTwo VSL" data-v-97bbe293><span class="then" data-v-97bbe293>return </span><span class="brackets" data-v-97bbe293>Object</span><span class="word" data-v-97bbe293>.keys</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>obj</span> <span class="brackets" data-v-97bbe293>)</span><span class="variable" data-v-97bbe293>.length</span><span class="then" data-v-97bbe293>===</span> <span class="number" data-v-97bbe293>0</span><div data-v-97bbe293></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div><br data-v-97bbe293><br data-v-97bbe293><div data-v-97bbe293><span class="function" data-v-97bbe293>function </span><span class="word" data-v-97bbe293>isEmpty3</span><span class="brackets" data-v-97bbe293>(</span> <span class="word" data-v-97bbe293>obj</span><span class="brackets" data-v-97bbe293>){</span></div><div class="padTwo VSL" data-v-97bbe293><span class="function" data-v-97bbe293>let </span> <span class="word" data-v-97bbe293>flag</span><span class="then" data-v-97bbe293>=</span> <span class="number" data-v-97bbe293>true</span><div data-v-97bbe293><span class="then" data-v-97bbe293>for </span> <span class="brackets" data-v-97bbe293>(</span><span class="function" data-v-97bbe293>const </span><span class="word" data-v-97bbe293>key</span> <span class="function" data-v-97bbe293>in </span><span class="word" data-v-97bbe293>obj</span> <span class="brackets" data-v-97bbe293>){</span></div><div data-v-97bbe293></div><div class="padTwo VSL" data-v-97bbe293><span class="then" data-v-97bbe293>if</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>key</span> <span class="brackets" data-v-97bbe293>){</span><div data-v-97bbe293></div><div class="padTwo VSL" data-v-97bbe293><span class="word" data-v-97bbe293>flag</span> <span class="then" data-v-97bbe293>=</span><span class="number" data-v-97bbe293>false</span><div data-v-97bbe293><span class="variable" data-v-97bbe293>break</span></div><div data-v-97bbe293></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div></div><div data-v-97bbe293><span class="then" data-v-97bbe293>return </span> <span class="word" data-v-97bbe293>flag</span></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div><br data-v-97bbe293><br data-v-97bbe293><div data-v-97bbe293><span class="function" data-v-97bbe293>function </span><span class="word" data-v-97bbe293>isEmpty4</span><span class="brackets" data-v-97bbe293>(</span> <span class="word" data-v-97bbe293>obj</span><span class="brackets" data-v-97bbe293>){</span></div><div class="padTwo VSL" data-v-97bbe293><span class="then" data-v-97bbe293>return </span><span class="brackets" data-v-97bbe293>Object</span><span class="word" data-v-97bbe293>.getOwnPropertyNames</span><span class="brackets" data-v-97bbe293>(</span> <span class="word" data-v-97bbe293>obj</span><span class="brackets" data-v-97bbe293>)</span><span class="variable" data-v-97bbe293>.length</span><span class="then" data-v-97bbe293>===</span> <span class="number" data-v-97bbe293>0</span><div data-v-97bbe293></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div></div><div id="onejs023" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ 如何判斷一個物件是否有某屬性? </div><p data-v-97bbe293>1. obj.hasOwnProperty(&quot;要找的屬性&quot;)</p><p data-v-97bbe293>返回 布林</p><br data-v-97bbe293><p data-v-97bbe293>只判斷 自身 , 不查找 原型鏈</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>2. obj.屬性 or obj方括號屬性 obj[&quot;屬性&quot;]</p><p data-v-97bbe293>來獲取 物件上 屬性值</p><br data-v-97bbe293><p data-v-97bbe293>如果不存在 , 返回 undefined</p><br data-v-97bbe293><p data-v-97bbe293> ( 物件 和 原型鏈 都沒這屬性 ) ( 不能用在 屬性存在 但值為 undefined 時 ) </p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>3. in 運算符</p><p data-v-97bbe293>&quot;屬性&quot; in obj , true 在物件 or 原型鏈有此屬性</p><br data-v-97bbe293><p data-v-97bbe293>( 會找自身 找原型鏈 )</p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs029" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ 合併 2 物件? </div><p data-v-97bbe293>const a = { name: &quot;wayne&quot;, age: 18 }</p><p data-v-97bbe293>const b = { sex: &quot;male&quot;, hobby: &quot;sleep&quot; }</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>方法1: Object.assign</p><p data-v-97bbe293>const a = { name: &quot;wayne&quot;, age: 18 }</p><p data-v-97bbe293>const b = { sex: &quot;male&quot;, hobby: &quot;sleep&quot; }</p><p class="comment" data-v-97bbe293> let obj = Object.assign( a, b ); //會改變 a 物件 </p><p data-v-97bbe293> let obj = Object.assign( {}, a, b ); <span class="comment" data-v-97bbe293>//用空物件,可以不改變a,b</span></p><p data-v-97bbe293>console.log( obj );</p><p class="comment" data-v-97bbe293> // { name:&quot;wayne&quot;,age:18,sex:&quot;male&quot;,hobby:&quot;sleep&quot; } </p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>方法2: 解構賦值 + ...擴展運算符</p><p data-v-97bbe293>const a = { name: &quot;wayne&quot;, age: 18 }</p><p data-v-97bbe293>const b = { sex: &quot;male&quot;, hobby: &quot;sleep&quot; }</p><p data-v-97bbe293>let obj = { ...a, ...b }</p><p data-v-97bbe293>console.log( obj );</p><p class="comment" data-v-97bbe293> // { name:&quot;wayne&quot;,age:18,sex:&quot;male&quot;,hobby:&quot;sleep&quot; } </p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>方法3: 遍歷 物件 a 物件 b</p><p data-v-97bbe293>const a = { name: &quot;wayne&quot;, age: 18 }</p><p data-v-97bbe293>const b = { sex: &quot;male&quot;, hobby: &quot;sleep&quot; }</p><p data-v-97bbe293>const obj = {}</p><p data-v-97bbe293>for ( let key in a ) {</p><p class="pTwo" data-v-97bbe293>obj[ key ] = a[ key ]</p><p data-v-97bbe293>}</p><p data-v-97bbe293>for ( let key in b)</p><p class="pTwo" data-v-97bbe293>obj[ key ] = b[ key ]</p><p data-v-97bbe293>}</p><p data-v-97bbe293>coneol.log ( obj )</p><p class="comment" data-v-97bbe293> // { name:&quot;wayne&quot;,age:18,sex:&quot;male&quot;,hobby:&quot;sleep&quot; } </p><div id="onejs005" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ let var const區別? </div><p data-v-97bbe293>var是ES5 let是ES6</p><p data-v-97bbe293>var是函數作用域 let支持塊級作用域</p><p data-v-97bbe293>var有變量提升 let沒有變量提升</p><p data-v-97bbe293>var可以重複聲明, let不能重複</p><p data-v-97bbe293>let和const的區別在於let可以重新賦值, const不行, 其他幾乎一樣</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>聲明1個var變數之後還能在聲明同名var變數嗎?</p><p data-v-97bbe293>可以 不會報錯</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>聲明1個let變數之後還能在聲明同名let變數嗎?</p><p data-v-97bbe293>不行 會報錯</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>聲明1個const變數之後還能在聲明同名const變數嗎?</p><p data-v-97bbe293>不行 會報錯</p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs006" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ 展開運算符 </div><p data-v-97bbe293> 展開運算符 是把一個陣列展開成個別值，這個運算符後面必定接著一個陣列。 </p><p data-v-97bbe293>最常見的是用來組合陣列，對應的陣列方法是concat</p><br data-v-97bbe293><p data-v-97bbe293> : 比如const a 等於, 然後一個陣列, 然後a點點點b, 這個b是一個舊陣列, 然後它會把a和b合成形成新陣列, 然後返回給變量 </p><br data-v-97bbe293><div class="bgcVS" data-v-97bbe293><br data-v-97bbe293><div data-v-97bbe293><span class="function" data-v-97bbe293>const </span> <span class="word" data-v-97bbe293>a</span><span class="then" data-v-97bbe293>=</span> <span class="brackets" data-v-97bbe293>[</span><span class="number" data-v-97bbe293>1, 2, 3</span><span class="brackets" data-v-97bbe293>]</span></div><div data-v-97bbe293><span class="function" data-v-97bbe293>const </span> <span class="word" data-v-97bbe293>b</span><span class="then" data-v-97bbe293>=</span> <span class="brackets" data-v-97bbe293>[</span><span class="number" data-v-97bbe293>4, 5, 6 </span><span class="brackets" data-v-97bbe293>]</span></div><br data-v-97bbe293><div class="comment" data-v-97bbe293>用於拼接陣列</div><div data-v-97bbe293><span class="function" data-v-97bbe293>const </span> <span class="word" data-v-97bbe293>c</span><span class="then" data-v-97bbe293>=</span> <span class="brackets" data-v-97bbe293>[</span><span class="word" data-v-97bbe293>...a,...b</span><span class="brackets" data-v-97bbe293>] </span><span class="comment" data-v-97bbe293>// [1,2,3,4,5,6]</span></div><br data-v-97bbe293><div class="comment" data-v-97bbe293>也可以</div><div data-v-97bbe293><span class="function" data-v-97bbe293>const </span> <span class="word" data-v-97bbe293>d</span><span class="then" data-v-97bbe293>=</span> <span class="brackets" data-v-97bbe293>[</span><span class="word" data-v-97bbe293>...a,</span><span class="number" data-v-97bbe293>4, 5, 6</span><span class="brackets" data-v-97bbe293>] </span><span class="comment" data-v-97bbe293>// [1,2,3,4,5,6]</span></div><br data-v-97bbe293><div class="comment" data-v-97bbe293>也可以</div><div data-v-97bbe293><span class="word" data-v-97bbe293>a.push</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>...b</span> <span class="brackets" data-v-97bbe293>)</span></div><div data-v-97bbe293><span class="word" data-v-97bbe293>console</span><span class="variable" data-v-97bbe293>.log</span><span class="brackets" data-v-97bbe293>(</span> <span class="word" data-v-97bbe293>a</span><span class="brackets" data-v-97bbe293>)</span></div><br data-v-97bbe293><div class="comment" data-v-97bbe293>可以做陣列淺拷貝</div><div data-v-97bbe293><span class="function" data-v-97bbe293>const </span> <span class="word" data-v-97bbe293>e</span><span class="then" data-v-97bbe293>=</span> <span class="brackets" data-v-97bbe293>[</span><span class="word" data-v-97bbe293>...a</span> <span class="brackets" data-v-97bbe293>]</span></div><div data-v-97bbe293><span class="word" data-v-97bbe293>e.push</span> <span class="brackets" data-v-97bbe293>(</span><span class="number" data-v-97bbe293>4</span> <span class="brackets" data-v-97bbe293>)</span><span class="comment" data-v-97bbe293>// 不會影響 a</span></div><br data-v-97bbe293><div class="comment" data-v-97bbe293> 淺拷貝是指複製值時，原本的變數和新的變數會指向同一個址 (reference) </div><div class="comment" data-v-97bbe293> 深拷貝是指在拷貝時不共享相同的址 (reference) </div><br data-v-97bbe293></div><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>a={...b} 可以嗎?</p><br data-v-97bbe293><div class="bgcVS" data-v-97bbe293><br data-v-97bbe293><div data-v-97bbe293><span class="function" data-v-97bbe293>const </span><span class="word" data-v-97bbe293>obj1</span> <span class="then" data-v-97bbe293>=</span><span class="brackets" data-v-97bbe293>{</span> <span class="word" data-v-97bbe293>a:</span><span class="number" data-v-97bbe293>1,</span> <span class="word" data-v-97bbe293>b:</span><span class="number" data-v-97bbe293>2</span> <span class="brackets" data-v-97bbe293>};</span></div><div data-v-97bbe293><span class="function" data-v-97bbe293>const </span><span class="word" data-v-97bbe293>obj2</span> <span class="then" data-v-97bbe293>=</span><span class="brackets" data-v-97bbe293>{</span> <span class="word" data-v-97bbe293>c:</span><span class="number" data-v-97bbe293>3,</span> <span class="word" data-v-97bbe293>d:</span><span class="number" data-v-97bbe293>4</span> <span class="brackets" data-v-97bbe293>};</span></div><br data-v-97bbe293><span class="comment" data-v-97bbe293>// 可以 拷貝 物件</span><div data-v-97bbe293><span class="function" data-v-97bbe293>const </span><span class="word" data-v-97bbe293>newObj</span> <span class="then" data-v-97bbe293>=</span><span class="brackets" data-v-97bbe293>{</span> <span class="word" data-v-97bbe293>...obj1</span><span class="brackets" data-v-97bbe293>}</span><span class="word" data-v-97bbe293></span></div><br data-v-97bbe293><span class="comment" data-v-97bbe293>// 可以 merged 2 個物件</span><div data-v-97bbe293><span class="function" data-v-97bbe293>const </span><span class="word" data-v-97bbe293>merged</span> <span class="then" data-v-97bbe293>=</span><span class="brackets" data-v-97bbe293>{</span><span class="word" data-v-97bbe293>...obj1,obj2</span><span class="brackets" data-v-97bbe293>};</span></div><div data-v-97bbe293><span class="word" data-v-97bbe293>console.</span><span class="variable" data-v-97bbe293>log</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>merged</span><span class="brackets" data-v-97bbe293>); </span><span class="comment" data-v-97bbe293>// {a: 1, b: 2, c: 3, d: 4 }</span></div><br data-v-97bbe293></div><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>這三個點除了把一個東西展開,它在函數參數有什麼用?</p><p data-v-97bbe293>可以不去命名那個函數的參數, 直接用函數參數對象裡面的某一個東西</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>參數裡面可不可以用三個點?</p><p data-v-97bbe293>可以</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>在賦值可以用三個點嗎?</p><p data-v-97bbe293>可以</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293> 我有一個陣列長度為10,我想把前面第一個元素命名為a,後面9個元素命名為新的數組叫b怎麼做? </p><p data-v-97bbe293> 方括號a然後點,然後逗號,然後點點點rest,然後方括號,然後等於array1,那就是a,那個a就是array裡的第一個 </p><br data-v-97bbe293><br data-v-97bbe293>',507),$={class:"bgcVS"},E=v('<br data-v-97bbe293><div class="comment" data-v-97bbe293>// 用於函數傳參</div><br data-v-97bbe293><div class="comment" data-v-97bbe293>// 實參的用法</div><div data-v-97bbe293><span class="function" data-v-97bbe293>const </span> <span class="word" data-v-97bbe293>a</span><span class="then" data-v-97bbe293>=</span> <span class="brackets" data-v-97bbe293>[</span><span class="number" data-v-97bbe293>1, 2, 3</span><span class="brackets" data-v-97bbe293>]</span></div>',5),_=t(()=>b("span",{class:"function"},"function ",-1)),A=t(()=>b("span",{class:"word"},"test",-1)),I=t(()=>b("span",{class:"brackets"},"(",-1)),M=t(()=>b("span",{class:"word"},"p1,p2,p3",-1)),B=t(()=>b("span",{class:"brackets"},"){",-1)),F=v('<div class="pTwo" data-v-97bbe293><span class="word" data-v-97bbe293>console.</span><span class="variable" data-v-97bbe293>log</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>p1</span> <span class="brackets" data-v-97bbe293>);</span></div><div class="pTwo" data-v-97bbe293><span class="word" data-v-97bbe293>console.</span><span class="variable" data-v-97bbe293>log</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>p2</span> <span class="brackets" data-v-97bbe293>);</span></div><div class="pTwo" data-v-97bbe293><span class="word" data-v-97bbe293>console.</span><span class="variable" data-v-97bbe293>log</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>p3</span> <span class="brackets" data-v-97bbe293>);</span></div><div class="brackets" data-v-97bbe293>}</div><div data-v-97bbe293><span class="word" data-v-97bbe293>test</span><span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>...a</span> <span class="brackets" data-v-97bbe293>)</span></div><br data-v-97bbe293><div data-v-97bbe293><span class="function" data-v-97bbe293>function </span><span class="word" data-v-97bbe293>sum</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>a,b,c</span> <span class="brackets" data-v-97bbe293>){</span></div><div class="pTwo" data-v-97bbe293><span class="then" data-v-97bbe293>return </span> <span class="word" data-v-97bbe293>a+b+c</span></div><span class="brackets" data-v-97bbe293>}</span><div data-v-97bbe293><span class="function" data-v-97bbe293>const </span><span class="word" data-v-97bbe293>sum</span> <span class="then" data-v-97bbe293>=</span><span class="brackets" data-v-97bbe293>(</span> <span class="word" data-v-97bbe293>a,b,c</span><span class="brackets" data-v-97bbe293>)</span> <span class="function" data-v-97bbe293>=&gt;</span><span class="word" data-v-97bbe293>a+b+c</span></div><div data-v-97bbe293><span class="word" data-v-97bbe293>sum</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>...a</span> <span class="brackets" data-v-97bbe293>) </span><span class="comment" data-v-97bbe293>// 6</span></div><br data-v-97bbe293><div data-v-97bbe293><span class="function" data-v-97bbe293>const </span><span class="word" data-v-97bbe293>sum</span> <span class="then" data-v-97bbe293>=</span><span class="word" data-v-97bbe293>sum</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>...a</span><span class="brackets" data-v-97bbe293>)</span></div><br data-v-97bbe293><div class="comment" data-v-97bbe293>// 形參的用法</div><div class="comment" data-v-97bbe293>// 形參的用法</div><div data-v-97bbe293><span class="word" data-v-97bbe293>conso.</span><span class="variable" data-v-97bbe293>log</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>Math.max</span><span class="brackets" data-v-97bbe293>(</span><span class="src" data-v-97bbe293>必須是字符的形式,不能直接接陣列,必須逗號隔開 </span><span class="brackets" data-v-97bbe293>)</span> <span class="brackets" data-v-97bbe293>)</span></div><div data-v-97bbe293><span class="word" data-v-97bbe293>conso.</span><span class="variable" data-v-97bbe293>log</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>Math.max</span><span class="brackets" data-v-97bbe293>(</span> <span class="number" data-v-97bbe293>1,2,3</span><span class="brackets" data-v-97bbe293>)</span> <span class="brackets" data-v-97bbe293>)</span><span class="comment" data-v-97bbe293>// 裡面要逗號</span></div><div class="comment" data-v-97bbe293>// 陣列沒有 求最大值 的方法</div><div data-v-97bbe293><span class="function" data-v-97bbe293>const </span> <span class="word" data-v-97bbe293>a</span><span class="then" data-v-97bbe293>=</span> <span class="brackets" data-v-97bbe293>[</span><span class="number" data-v-97bbe293>1, 2, 3</span><span class="brackets" data-v-97bbe293>]</span></div><div data-v-97bbe293><span class="function" data-v-97bbe293>const </span> <span class="word" data-v-97bbe293>b</span><span class="then" data-v-97bbe293>=</span> <span class="brackets" data-v-97bbe293>[</span><span class="number" data-v-97bbe293>4, 5, 6</span><span class="brackets" data-v-97bbe293>]</span></div><div data-v-97bbe293><span class="word" data-v-97bbe293>console.</span><span class="variable" data-v-97bbe293>log</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>...a</span><span class="brackets" data-v-97bbe293>)</span><span class="comment" data-v-97bbe293>// 1 2 3</span><span class="comment" data-v-97bbe293>// 打印沒逗號,一樣能用在.max</span></div><span class="comment" data-v-97bbe293>...a === 1,2,3</span><div data-v-97bbe293><span class="word" data-v-97bbe293>console.</span><span class="variable" data-v-97bbe293>log</span> <span class="word" data-v-97bbe293>Math</span><span class="variable" data-v-97bbe293>.max</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>...a</span><span class="brackets" data-v-97bbe293>)</span> <span class="comment" data-v-97bbe293>// 3</span></div><div data-v-97bbe293><span class="word" data-v-97bbe293>console.</span><span class="variable" data-v-97bbe293>log</span> <span class="word" data-v-97bbe293>Math</span><span class="variable" data-v-97bbe293>.min</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>...a</span><span class="brackets" data-v-97bbe293>)</span> <span class="comment" data-v-97bbe293>// 3</span></div><div data-v-97bbe293><span class="word" data-v-97bbe293>console.</span><span class="variable" data-v-97bbe293>log</span> <span class="word" data-v-97bbe293>Math</span><span class="variable" data-v-97bbe293>.max</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>...a,...b</span><span class="brackets" data-v-97bbe293>)</span> <span class="comment" data-v-97bbe293>// 6</span></div><br data-v-97bbe293><div class="comment" data-v-97bbe293>// 形參 &amp; 實參</div><div data-v-97bbe293><span class="function" data-v-97bbe293>function </span><span class="word" data-v-97bbe293>test</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>形參1,形參2</span><span class="brackets" data-v-97bbe293>){ </span><span class="comment" data-v-97bbe293>// 函數聲明的小括號裡是 形參 </span></div><div class="comment pTwo" data-v-97bbe293>// 代碼</div><div class="brackets" data-v-97bbe293>}</div><div data-v-97bbe293><span class="word" data-v-97bbe293>test</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>實參1,實參2</span><span class="brackets" data-v-97bbe293>) </span><span class="comment" data-v-97bbe293>// 函數調用的小括號裡是 實參</span></div><br data-v-97bbe293>',33),H=v('<div id="" class="articleCardTitle cor36" data-v-97bbe293>[ JS ] ≫ 操作陣列?</div><p data-v-97bbe293>push pop unshift shift reduce find include</p><div id="onejs007" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ 遍歷數組有幾種方式? </div><p data-v-97bbe293>for . forEach</p><br data-v-97bbe293><p data-v-97bbe293> map: 返回一個新數組 , 數組中的元素為 原始數組元素 調用函數 處理後的值 </p><br data-v-97bbe293><p data-v-97bbe293> filter: 創建一個新數組 , 數組中的元素 是通過檢查指定數組中 符合條件的 所有元素 </p><br data-v-97bbe293><p data-v-97bbe293>every: 每一個元素都滿足條件 返回 true , 否則 返回 false</p><br data-v-97bbe293><p data-v-97bbe293> some: 只要有一個以上的元素滿足條件 就 返回 true , 否則 返回 false , 退出循環 </p><br data-v-97bbe293><p data-v-97bbe293>reduce: 對數組中的 每個元素 執行一個 回掉函數 , 將其結果返回值</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293># forEach和map的區別?</p><p data-v-97bbe293> map需要有個返回值把它再返回到陣列, 它會接收到那個值, 修改當前元素 </p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293># for in,for of,他們用在什麼場景?</p><p data-v-97bbe293>for of 循環獲取到的是一對鍵值對中的值 , 也就是 value</p><br data-v-97bbe293><p data-v-97bbe293>而 for in 獲取的是鍵名 , 也就是 key</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>對數組 for of 返回的是 數組裡面的 元素值</p><br data-v-97bbe293><p data-v-97bbe293>for in 返回 key , 指每個元素的 索引值</p><br data-v-97bbe293><p data-v-97bbe293> for of 只能遍歷其底層帶有 iterator 接口的 數據結構 像 set map string array </p><br data-v-97bbe293><p data-v-97bbe293>物件沒有原生 iterator 接口 , 直接用 for of 會報錯</p><br data-v-97bbe293><p data-v-97bbe293>開發中 遍歷用 for in 更合適</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>for in 返回 數組元素的 索引值 , 而不是 元素</p><br data-v-97bbe293><p data-v-97bbe293>而且 遍歷順序 有可能不是按照 實際數據的 內部順序</p><br data-v-97bbe293><p data-v-97bbe293>所以 通常遍歷數組用 for of</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>總之 for in 適合遍歷 物件</p><p data-v-97bbe293>for of 適合遍歷 數組</p><div class="bgcVS" data-v-97bbe293><div data-v-97bbe293><span class="comment" data-v-97bbe293>// 1. 循環數組</span></div><div data-v-97bbe293><span class="word" data-v-97bbe293>cosnt</span> <span class="word" data-v-97bbe293>arr</span><span class="then" data-v-97bbe293>=</span> <span class="brackets" data-v-97bbe293>[</span><span class="src" data-v-97bbe293>&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;</span><span class="brackets" data-v-97bbe293>]</span></div><div data-v-97bbe293><span class="comment" data-v-97bbe293>// for...in 輸出 數組成員 在數組中 的索引</span></div><div data-v-97bbe293><span class="then" data-v-97bbe293>for </span> <span class="brackets" data-v-97bbe293>(</span><span class="function" data-v-97bbe293>let </span> <span class="word" data-v-97bbe293>n </span><span class="function" data-v-97bbe293>in </span> <span class="word" data-v-97bbe293>arr</span><span class="brackets" data-v-97bbe293>){</span></div><div class="padTwo VSL" data-v-97bbe293><span class="word" data-v-97bbe293>console.log</span><span class="brackets" data-v-97bbe293>(</span> <span class="word" data-v-97bbe293>n </span><span class="brackets" data-v-97bbe293>) </span><span class="comment" data-v-97bbe293>// 0 // 1 // 2 // 3</span><div data-v-97bbe293></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div><br data-v-97bbe293><div data-v-97bbe293><span class="comment" data-v-97bbe293>// for...of 輸出 數組的成員</span></div><div data-v-97bbe293><span class="then" data-v-97bbe293>for </span> <span class="brackets" data-v-97bbe293>(</span><span class="function" data-v-97bbe293>let </span> <span class="word" data-v-97bbe293>n </span><span class="function" data-v-97bbe293>of </span> <span class="word" data-v-97bbe293>arr</span><span class="brackets" data-v-97bbe293>){</span></div><div class="padTwo VSL" data-v-97bbe293><span class="word" data-v-97bbe293>console.log</span><span class="brackets" data-v-97bbe293>(</span> <span class="word" data-v-97bbe293>n </span><span class="brackets" data-v-97bbe293>) </span><span class="comment" data-v-97bbe293>// a // b // c // d</span><div data-v-97bbe293></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div><br data-v-97bbe293><div data-v-97bbe293><span class="comment" data-v-97bbe293>// 2. 循環物件</span></div><div data-v-97bbe293><span class="function" data-v-97bbe293>const </span><span class="word" data-v-97bbe293>obj</span> <span class="then" data-v-97bbe293>=</span><span class="brackets" data-v-97bbe293>{</span> <span class="word" data-v-97bbe293>n:</span><span class="number" data-v-97bbe293>4,</span> <span class="word" data-v-97bbe293>m:</span><span class="number" data-v-97bbe293>5,</span> <span class="word" data-v-97bbe293>k:</span><span class="number" data-v-97bbe293>6</span> <span class="brackets" data-v-97bbe293>}</span></div><div data-v-97bbe293><span class="comment" data-v-97bbe293>// for...in </span></div><div data-v-97bbe293><span class="then" data-v-97bbe293>for </span> <span class="brackets" data-v-97bbe293>(</span><span class="function" data-v-97bbe293>let </span> <span class="word" data-v-97bbe293>n </span><span class="function" data-v-97bbe293>in </span> <span class="word" data-v-97bbe293>obj</span><span class="brackets" data-v-97bbe293>){</span></div><div class="padTwo VSL" data-v-97bbe293><span class="comment" data-v-97bbe293>// 物件的屬性名</span></div><div class="padTwo VSL" data-v-97bbe293><span class="word" data-v-97bbe293>console.log</span><span class="brackets" data-v-97bbe293>(</span> <span class="word" data-v-97bbe293>n</span><span class="brackets" data-v-97bbe293>) </span><span class="comment" data-v-97bbe293>// n // m // k</span><div data-v-97bbe293></div></div><div class="padTwo VSL" data-v-97bbe293><span class="comment" data-v-97bbe293>// 物件的屬性值</span></div><div class="padTwo VSL" data-v-97bbe293><span class="word" data-v-97bbe293>console.</span><span class="variable" data-v-97bbe293>log</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>obj</span> <span class="brackets" data-v-97bbe293>[</span><span class="word" data-v-97bbe293>n</span> <span class="brackets" data-v-97bbe293>])</span><span class="comment" data-v-97bbe293>// 4 // 5 // 6</span><div data-v-97bbe293></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div><br data-v-97bbe293><div data-v-97bbe293><span class="comment" data-v-97bbe293>// for...of </span></div><div data-v-97bbe293><span class="then" data-v-97bbe293>for </span> <span class="brackets" data-v-97bbe293>(</span><span class="function" data-v-97bbe293>let </span> <span class="word" data-v-97bbe293>n </span><span class="function" data-v-97bbe293>of </span> <span class="word" data-v-97bbe293>obj</span><span class="brackets" data-v-97bbe293>){</span></div><div class="padTwo VSL" data-v-97bbe293><div data-v-97bbe293><span class="comment" data-v-97bbe293>// 報錯 , 不能循環</span></div><div data-v-97bbe293><span class="comment" data-v-97bbe293>// 因為沒有 iterator 接口</span></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div><br data-v-97bbe293><div data-v-97bbe293><span class="comment" data-v-97bbe293>// 3. 循環數組物件</span></div><div data-v-97bbe293><span class="function" data-v-97bbe293>const </span><span class="word" data-v-97bbe293>arrObj</span> <span class="then" data-v-97bbe293>=</span><span class="brackets" data-v-97bbe293>[{</span></div><div class="padTwo VSL" data-v-97bbe293><span class="word" data-v-97bbe293>name:</span> <span class="src" data-v-97bbe293>&quot;wayne&quot;,</span><div data-v-97bbe293></div></div><div class="padTwo VSL" data-v-97bbe293><span class="word" data-v-97bbe293>number:</span> <span class="number" data-v-97bbe293>1</span><div data-v-97bbe293></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}, {</span></div><div class="padTwo VSL" data-v-97bbe293><span class="word" data-v-97bbe293>name:</span> <span class="src" data-v-97bbe293>&quot;jack&quot;,</span><div data-v-97bbe293></div></div><div class="padTwo VSL" data-v-97bbe293><span class="word" data-v-97bbe293>number:</span> <span class="number" data-v-97bbe293>9</span><div data-v-97bbe293></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}]</span></div><br data-v-97bbe293><div data-v-97bbe293><span class="then" data-v-97bbe293>for </span> <span class="brackets" data-v-97bbe293>(</span><span class="function" data-v-97bbe293>let </span> <span class="word" data-v-97bbe293>nObj </span><span class="function" data-v-97bbe293>of </span><span class="word" data-v-97bbe293>arrObj</span> <span class="brackets" data-v-97bbe293>){</span></div><div class="padTwo VSL" data-v-97bbe293><span class="word" data-v-97bbe293>console.</span><span class="variable" data-v-97bbe293>log</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>nObj</span> <span class="brackets" data-v-97bbe293>)</span><span class="comment" data-v-97bbe293>//{name:&quot;wayne&quot;,number:1},{name:&quot;jack&quot;,number:9}</span></div><div class="padTwo VSL" data-v-97bbe293><span class="then" data-v-97bbe293>for </span> <span class="brackets" data-v-97bbe293>(</span><span class="function" data-v-97bbe293>let </span> <span class="word" data-v-97bbe293>n </span><span class="function" data-v-97bbe293>in </span> <span class="word" data-v-97bbe293>nObj</span><span class="brackets" data-v-97bbe293>){</span><div data-v-97bbe293><div class="padTwo VSL" data-v-97bbe293><span class="word" data-v-97bbe293>console.</span><span class="variable" data-v-97bbe293>log</span><span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>nObj</span><span class="brackets" data-v-97bbe293>[</span> <span class="word" data-v-97bbe293>n</span><span class="brackets" data-v-97bbe293>]) </span><span class="comment" data-v-97bbe293>// wayne // 1 // jack // 9</span><div data-v-97bbe293></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div><div data-v-97bbe293><span class="comment" data-v-97bbe293>// for in 循環 物件</span></div><div data-v-97bbe293><span class="comment" data-v-97bbe293>// for of 循環 數組</span></div></div><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293># for循環遍歷跟forEach遍歷,for循環可以中斷嗎?</p><p data-v-97bbe293>for 可以中斷 , forEach 不能中斷</p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs008" class="articleCardTitle cor36" data-v-97bbe293>[ JS ] ≫ 閉包?</div><p class="comment" data-v-97bbe293>什麼是閉包 , 概念 , 用途 , 優 缺點</p><br data-v-97bbe293><p data-v-97bbe293>閉包 就是 有權訪問 另一個 函數作用域的變量 的函數</p><br data-v-97bbe293><p data-v-97bbe293>優點是 私有化數據 在 私有化數據的基礎上 保持數據</p><br data-v-97bbe293><p data-v-97bbe293>私有化數據是 把一些變量 私有化到函數裡面</p><br data-v-97bbe293><p data-v-97bbe293>為了保持數據</p><br data-v-97bbe293><p data-v-97bbe293> 例如 節流防抖 -&gt; 當第一次點擊時 , 我們 let time = 接收他的定時器 </p><br data-v-97bbe293><p data-v-97bbe293> 如果不用閉包暫存他 , 下次點擊 他是重新創建函數 , 也就重創一個定時器 </p><br data-v-97bbe293><p data-v-97bbe293>他們 2 個不是互通的 , 沒有引用做連通</p><br data-v-97bbe293><p data-v-97bbe293>也就是 使用閉包 他不會在 內存中消失</p><br data-v-97bbe293><p data-v-97bbe293>所以我們在下次 調用時 能獲取到 上一次定時器的 時間</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>缺點 可能導致內存洩漏</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293># 閉包一定會造成內存洩漏嗎?</p><p data-v-97bbe293>不一定 , 看瀏覽器垃圾回收機制</p><br data-v-97bbe293><p data-v-97bbe293> 閉包造成內存洩漏是瀏覽器問題, 它沒有及時的清裡內存, 所以是閉包容易造成內存洩漏, 因為實現閉包的拉圾回收比普通變量難一點, 歷史上發生的有IE6IE7, 但現在已經沒有了 </p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>閉包的目的? 用來封裝一個數據,提供一些API給外部使用</p><br data-v-97bbe293><p data-v-97bbe293>物件的目的? 內部包含一些數據,提供一些方法給外部使用</p><br data-v-97bbe293><p data-v-97bbe293> 閉包和物件的區別?(閉包是在你不想用物件時來代替物件) 物件的拆卸數據可以透過屬性暴露出來, 閉包想要暴露那些數據你得單獨給他寫個函數 </p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs009" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ JS 的立即執行函數是幹嘛用的?? </div><p data-v-97bbe293>避免汙染全局環境</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293># IIFE立即執行函數它的語法?</p><p data-v-97bbe293>一個匿名函數, 外面包一層括號, 後面再加一個小括號</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293># 為什麼要包一層括號,後面再加一個小括號?</p><p data-v-97bbe293> 把函數看成一個整體, 首先你匿名函數可以以傳參的形式存在, 也可以以一些其他形式存在, 但是你不行就直接寫在一段JS的外部, 這樣他語法就通過不了, 因為它不是一個整體, 你function後面直接跟一個括號, 他不知道是甚麼東西 </p><br data-v-97bbe293><div id="onejs010" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ this 指向 </div><p data-v-97bbe293>1. 全局對象 的 this 指向</p><p data-v-97bbe293>指向 window</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>2. 全局作用域 or 普通函數中的 this</p><p data-v-97bbe293>指向 window</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>3. this 指向最後調用他的那個對象</p><p data-v-97bbe293>在不是 箭頭函數 情況下</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>4. new 關鍵字改變 this 指向</p><p data-v-97bbe293></p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293></p><p data-v-97bbe293></p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293></p><p data-v-97bbe293></p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293></p><p data-v-97bbe293></p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293></p><p data-v-97bbe293></p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293></p><p data-v-97bbe293></p><table data-v-97bbe293><tr data-v-97bbe293><th data-v-97bbe293><div class="pad20" data-v-97bbe293>調用方式</div></th><th data-v-97bbe293><div class="pad20" data-v-97bbe293>示例</div></th><th data-v-97bbe293><div class="pad20" data-v-97bbe293>函數中this指向</div></th></tr><tr data-v-97bbe293><td data-v-97bbe293><div class="pad20" data-v-97bbe293>通過new調用</div></td><td data-v-97bbe293><div class="pad20" data-v-97bbe293>mew method()</div></td><td data-v-97bbe293><div class="pad20" data-v-97bbe293>新物件</div></td></tr><tr data-v-97bbe293><td data-v-97bbe293><div class="pad20" data-v-97bbe293>直接調用</div></td><td data-v-97bbe293><div class="pad20" data-v-97bbe293>method()</div></td><td data-v-97bbe293><div class="pad20" data-v-97bbe293>全局對象window</div></td></tr><tr data-v-97bbe293><td data-v-97bbe293><div class="pad20" data-v-97bbe293>通過物件調用</div></td><td data-v-97bbe293><div class="pad20" data-v-97bbe293>obj.method()</div></td><td data-v-97bbe293><div class="pad20" data-v-97bbe293>前面的物件</div></td></tr><tr data-v-97bbe293><td data-v-97bbe293><div class="pad20" data-v-97bbe293>call.apply.bind</div></td><td data-v-97bbe293><div class="pad20" data-v-97bbe293>method.call(ctx)</div></td><td data-v-97bbe293><div class="pad20" data-v-97bbe293>第一個參數</div></td></tr></table><div id="onejs011" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ 箭頭函數和普通function有甚麼區別? </div><p data-v-97bbe293>在執行過程中不會初始化 this</p><br data-v-97bbe293><p data-v-97bbe293>不會初始化 aruguments</p><br data-v-97bbe293><p data-v-97bbe293>不能被 new</p><br data-v-97bbe293><p data-v-97bbe293>沒有 prototype</p><br data-v-97bbe293><p data-v-97bbe293>不能當成構造函數執行</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293># 箭頭函數什麼情況可以省略return?</p><p data-v-97bbe293>不加括弧號的時候, 只有一個語句(一句代碼,可以有多個分號)</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293># 箭頭函數的this指向哪裡?</p><p data-v-97bbe293>外部的this or (捕獲其上下文中的this)</p><br data-v-97bbe293><p data-v-97bbe293>箭頭函數不創建 this , 他從自己的作用域鏈的上一層沿用 this</p><div id="onejs012" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ 原型鏈是什麼? </div><p class="cor36" data-v-97bbe293>物件,原型,物件的構造函數間的關係?</p><br data-v-97bbe293><p data-v-97bbe293>首先任何物件都會有屬於它的隱藏屬性下滑線proto屬性__proto__</p><br data-v-97bbe293><p data-v-97bbe293>這個隱藏屬性就會指向它的構造函數的prototype</p><br data-v-97bbe293><p data-v-97bbe293>這時我們就可以說這個物件的原型就是它的構造函數的prototype</p><br data-v-97bbe293><p data-v-97bbe293>這就是原型</p><br data-v-97bbe293><p data-v-97bbe293> 然後原型鏈就是比如A的原型是B, B的原型是C, 這樣一條像鏈式的就稱為原型鏈 </p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293> : 定義一個物件A,它的原型的地址對應著object.prototype,object.prototype它的原型又會到了null 這樣一條像鏈式的就稱為原型鏈 </p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>A指向一個物件,意味著A存的是什麼東西?(注意JS沒有指向) A它的地址</p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs013" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ new 做了什麼? </div><br data-v-97bbe293><p data-v-97bbe293>new後面跟一個構造函數</p><br data-v-97bbe293><p data-v-97bbe293>先創造一個臨時物件</p><br data-v-97bbe293><p data-v-97bbe293>將這個 臨時物件 原型 綁定構造函數的 prototype</p><br data-v-97bbe293><p data-v-97bbe293>再把裡面的 this 指定為這個 臨時物件</p><br data-v-97bbe293><p data-v-97bbe293>再執行構造函數</p><br data-v-97bbe293><p data-v-97bbe293>最後return這個臨時物件</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293># 當我 new 構造函數</p><p data-v-97bbe293>1. 創建 新物件 (空的)</p><p data-v-97bbe293>2. 構造函數的 this 指向 新物件</p><p data-v-97bbe293>3. 執行 構造函數 代碼</p><p class="pFou" data-v-97bbe293>this. 指向物件 . . . obj.name=&quot;wayne&quot;</p><p class="pFou" data-v-97bbe293>name屬性 =賦值 &quot;wayne&quot;</p><p data-v-97bbe293>4. 返回 這個 新物件</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293> # 如果我再new後面構造函數後面最後一行加一個return一個數組會怎樣? </p><p data-v-97bbe293>它就會代替這個 this</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293> # 如果我再new後面構造函數後面最後一行加一個return一個物件會怎樣? </p><p data-v-97bbe293>它就會代替這個 this</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293># 原型綁定是綁到這個this的哪個屬性上面?</p><p data-v-97bbe293>__proto__</p><br data-v-97bbe293><p data-v-97bbe293>new後面跟一個構造函數,這個函數可以是箭頭函數嗎? _ 不可以</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293># 你new出來的對象原型是什麼?</p><p data-v-97bbe293>new 出來的 物件的 原型 指向 構造函數的 原型</p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs014" class="articleCardTitle cor36" data-v-97bbe293>[ JS ] ≫ 繼承?</div><p class="cor36" data-v-97bbe293>1. 原型鏈繼承</p><p data-v-97bbe293>每個 構造函數 都有一個 原型對象 (prototype),</p><br data-v-97bbe293><p data-v-97bbe293>每個 實例對象 包含一個 指向 原型對象的 指針 (__proto__)</p><br data-v-97bbe293><p data-v-97bbe293>當代碼 讀取實例的 某屬性時 ,</p><br data-v-97bbe293><p data-v-97bbe293>都會先在 實例上 搜尋這個屬性, 沒找到 則搜索原型對象</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>缺點</p><p data-v-97bbe293> 包含引用類型值的 原型屬性 會被所有實例共享。 ( 當一個實例改變該屬性 , 其他也會改 ) </p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>2. 構造函數繼承</p><p data-v-97bbe293>通過使用 call apply 方法 ,</p><br data-v-97bbe293><p data-v-97bbe293>可以在子類中 執行父類 構造函數 , 從而實現繼承</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>優點</p><p data-v-97bbe293>原型屬性 不會 被共享</p><p class="cor36" data-v-97bbe293>缺點</p><p data-v-97bbe293>不能繼承 父類 prototype 上的屬性</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>3. 構造函數繼承 + 構造函數繼承</p><p data-v-97bbe293>child.prototype = new Parent()</p><p class="cor36" data-v-97bbe293>優點</p><p data-v-97bbe293>1. 原型屬性不會被共享</p><p data-v-97bbe293>2. 可以繼承父類的 原型鏈上的 屬性和方法</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>點</p><p data-v-97bbe293>調用了 2 次 Parent()</p><p data-v-97bbe293>他在 child 的 prototype 上添加了父類的 屬性和方法</p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs015" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ call apply bind </div><p class="cor36" data-v-97bbe293>call和apply有什麼區別?</p><p data-v-97bbe293>call指定一個this, 傳參數, 直接調用他,</p><br data-v-97bbe293><p data-v-97bbe293>apply指定this, 傳的參數是放在陣列裡面的, 也是直接調用</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>什麼情況下只能用apply不能用call?</p><p data-v-97bbe293>你要傳的數據是陣列的話用apply, 你傳的參數很多也用apply</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293># 現在ES6,我能不能強行用call? _ 可以</p><p data-v-97bbe293> sumNumbers.call(null, ...numbers); 直接函數.call,null三個點把那個陣列展開 </p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293># call和bind有什麼區別?</p><p data-v-97bbe293> bind只綁定this,但它不去立即調用它,而是返回一個綁定這個this的新函數 </p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs016" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ 防抖是什麼? </div><p data-v-97bbe293> 防斗比如一個input標籤, 然後input標籤要實現一個功能, 再用戶輸入的時候彈出相應的提示, </p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>所以監聽它的input事件, 但是input事件是在用戶每次輸入的時候觸發,</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>所以需要設置一個函數的防斗來實現一個功能,</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>就是當用戶輸入之後停頓某個時間沒有再次輸入才會執行這個函數,</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>否則不執行, 重新計時</p><br data-v-97bbe293><br data-v-97bbe293><div class="bgcVS" data-v-97bbe293><div data-v-97bbe293><span class="then" data-v-97bbe293>＜</span> <span class="number" data-v-97bbe293>input </span><span class="word" data-v-97bbe293>type</span> <span class="then" data-v-97bbe293>=</span><span class="src" data-v-97bbe293>&quot;text&quot;</span> <span class="then" data-v-97bbe293>&gt;</span></div><div data-v-97bbe293><span class="function" data-v-97bbe293>let </span><span class="word" data-v-97bbe293>oInput</span> <span class="then" data-v-97bbe293>=</span><span class="word" data-v-97bbe293>document</span><span class="variable" data-v-97bbe293>.querySelector</span><span class="brackets" data-v-97bbe293>(</span> <span class="src" data-v-97bbe293>&quot;input&quot;</span><span class="brackets" data-v-97bbe293>)</span></div><div data-v-97bbe293><span class="function" data-v-97bbe293>let </span> <span class="word" data-v-97bbe293>time</span><span class="then" data-v-97bbe293>=</span> <span class="then" data-v-97bbe293>null</span></div><div data-v-97bbe293><span class="word" data-v-97bbe293>oInput</span><span class="variable" data-v-97bbe293>.oninput</span><span class="then" data-v-97bbe293>=</span><span class="word" data-v-97bbe293>debounce</span><span class="brackets" data-v-97bbe293>(</span><span class="variable" data-v-97bbe293>function</span><span class="brackets" data-v-97bbe293>(){</span></div><div class="padTwo VSL" data-v-97bbe293><span class="word" data-v-97bbe293>console</span><span class="variable" data-v-97bbe293>.log</span><span class="brackets" data-v-97bbe293>(</span><span class="then" data-v-97bbe293>this</span><span class="brackets" data-v-97bbe293>) </span><div data-v-97bbe293></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>},</span><span class="number" data-v-97bbe293>1000</span><span class="brackets" data-v-97bbe293>)</span></div><div data-v-97bbe293><span class="function" data-v-97bbe293>function </span><span class="word" data-v-97bbe293>debounce</span><span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>fn,delay</span><span class="brackets" data-v-97bbe293>){</span></div><div class="padTwo VSL" data-v-97bbe293><div data-v-97bbe293><span class="comment" data-v-97bbe293>//console.log(this)</span></div><span class="function" data-v-97bbe293>let </span><span class="word" data-v-97bbe293>time</span> <span class="then" data-v-97bbe293>=</span><span class="then" data-v-97bbe293>null</span><div data-v-97bbe293></div><span class="then" data-v-97bbe293>return </span><span class="function" data-v-97bbe293>function </span><span class="brackets" data-v-97bbe293>(){</span><div data-v-97bbe293></div><div class="padTwo VSL" data-v-97bbe293><span class="then" data-v-97bbe293>if</span><span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>time</span><span class="then" data-v-97bbe293>!==null</span><span class="brackets" data-v-97bbe293>){</span><div data-v-97bbe293></div><div class="padTwo VSL" data-v-97bbe293><span class="word" data-v-97bbe293>clearTimeout</span><span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>t</span><span class="brackets" data-v-97bbe293>)</span><div data-v-97bbe293></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div><div data-v-97bbe293><span class="word" data-v-97bbe293>time</span><span class="then" data-v-97bbe293>=</span><span class="variable" data-v-97bbe293>setTimeout</span><span class="brackets" data-v-97bbe293>(()</span><span class="function" data-v-97bbe293>=&gt; </span><span class="brackets" data-v-97bbe293>{</span><div class="padTwo VSL" data-v-97bbe293><span class="variable" data-v-97bbe293>fn</span><span class="number" data-v-97bbe293>.call</span><span class="brackets" data-v-97bbe293>(</span><span class="then" data-v-97bbe293>this</span><span class="brackets" data-v-97bbe293>)</span><span class="brackets" data-v-97bbe293>()</span></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>},</span><span class="number" data-v-97bbe293>delay</span><span class="brackets" data-v-97bbe293>)</span></div></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div></div><p class="cor36" data-v-97bbe293>節流是什麼?</p><p data-v-97bbe293> 節流類似一個技能的冷卻, 就是當你進行一個操作後, 要等一段時間才能再次進行這個操作, </p><div class="bgcVS" data-v-97bbe293><div data-v-97bbe293><span class="word" data-v-97bbe293>window</span><span class="variable" data-v-97bbe293>.onscroll</span><span class="then" data-v-97bbe293>=</span> <span class="word" data-v-97bbe293>throttle</span><span class="brackets" data-v-97bbe293>(</span><span class="function" data-v-97bbe293>function </span><span class="brackets" data-v-97bbe293>(){</span></div><div class="padTwo VSL" data-v-97bbe293><span class="variable" data-v-97bbe293>alert</span><span class="brackets" data-v-97bbe293>(</span> <span class="src" data-v-97bbe293>&quot;廣告&quot;</span><span class="brackets" data-v-97bbe293>)</span><div data-v-97bbe293></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>},</span> <span class="number" data-v-97bbe293>2000</span><span class="brackets" data-v-97bbe293>)</span></div><div data-v-97bbe293><span class="function" data-v-97bbe293>function </span><span class="word" data-v-97bbe293>throttle</span><span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>fn,delay</span><span class="brackets" data-v-97bbe293>){</span></div><div class="padTwo VSL" data-v-97bbe293><span class="function" data-v-97bbe293>let </span> <span class="word" data-v-97bbe293>time</span><span class="then" data-v-97bbe293>=</span> <span class="number" data-v-97bbe293>true</span><div data-v-97bbe293></div><span class="then" data-v-97bbe293>return </span><span class="function" data-v-97bbe293>function </span><span class="brackets" data-v-97bbe293>(){</span><div data-v-97bbe293></div><div class="padTwo VSL" data-v-97bbe293><span class="then" data-v-97bbe293>if</span> <span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>time</span> <span class="brackets" data-v-97bbe293>){</span><div data-v-97bbe293></div><div class="padTwo VSL" data-v-97bbe293><span class="variable" data-v-97bbe293>setTimeout</span><span class="brackets" data-v-97bbe293>(()</span><span class="function" data-v-97bbe293>=&gt;</span><span class="brackets" data-v-97bbe293>{</span><div data-v-97bbe293></div><div class="padTwo VSL" data-v-97bbe293><span class="word" data-v-97bbe293>fn</span><span class="variable" data-v-97bbe293>.call</span><span class="brackets" data-v-97bbe293>(</span><span class="then" data-v-97bbe293>this</span><span class="brackets" data-v-97bbe293>) </span><span class="comment" data-v-97bbe293>// 綁在 window 有沒有 call 都可以</span><div data-v-97bbe293><span class="word" data-v-97bbe293>time</span><span class="then" data-v-97bbe293>=</span><span class="number" data-v-97bbe293>true</span></div><div data-v-97bbe293></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>},</span><span class="word" data-v-97bbe293>delay</span><span class="brackets" data-v-97bbe293>)</span></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div><div data-v-97bbe293><span class="word" data-v-97bbe293>time</span> <span class="then" data-v-97bbe293>=</span><span class="number" data-v-97bbe293>false</span></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div></div><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>proxy做什麼的?</p><p data-v-97bbe293> 用於接管物件內部屬性的讀取或函數的調用方法, 它跟object.definedproperty是一樣的功能, 但是object.definedproperty一次只能處理一個屬性 </p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs017" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ 什麼是DOM? </div><p data-v-97bbe293>DOM是文檔物件模型</p><br data-v-97bbe293><p data-v-97bbe293>用途是把網頁變成JS中的對象來進行增刪改查操作</p><br data-v-97bbe293><p data-v-97bbe293>平時要操作DOM可以通過document.getElementByID</p><br data-v-97bbe293><p data-v-97bbe293>然後去對他的各種屬性進行修改,</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>什麼是事件捕獲?什麼是事件冒泡?</p><p data-v-97bbe293> 事件捕獲是從最外層然後向觸發事件子層去一層一層往下傳遞事件, 冒泡是從子層向外層一層一層冒泡這個事件 </p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>那一次點擊會同時觸發捕獲和冒泡嗎?</p><p data-v-97bbe293>會,不管什麼事件一定會先捕獲在冒泡</p><br data-v-97bbe293><p data-v-97bbe293>先從document一層一層的到那個元素</p><br data-v-97bbe293><p data-v-97bbe293>然後再從那個元素一層一層到 document</p><br data-v-97bbe293><p data-v-97bbe293>你監聽捕獲只不過是在其中插入一個函數而已</p><br data-v-97bbe293><p data-v-97bbe293>監聽捕獲是在捕獲那邊插入函數</p><br data-v-97bbe293><p data-v-97bbe293>監聽冒泡是在冒泡那邊插入一個函數</p><br data-v-97bbe293><p data-v-97bbe293> 如果你兩個都監聽還是先經過捕獲階段觸發你的函數, 經過冒泡階段在觸發函數 </p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293># BOM</p><br data-v-97bbe293><p data-v-97bbe293>BOM是瀏覽器對象模型, 用途是用JS來操作瀏覽器來前進後退和地址欄</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293># DOM的事件模型是什麼?</p><p data-v-97bbe293>觸發事件時, 先從上往下進行事件捕獲階段</p><br data-v-97bbe293><p data-v-97bbe293>從觸發結點最上面 document 往下到觸發節點</p><br data-v-97bbe293><p data-v-97bbe293>然後監聽事件有沒有發生</p><br data-v-97bbe293><p data-v-97bbe293>要有同類型事件發生的話就執行函數</p><br data-v-97bbe293><p data-v-97bbe293>之後再從這個節點往上進行事件冒泡</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293># 不想某一個元素往上冒泡可以用什麼API?</p><br data-v-97bbe293><p data-v-97bbe293>e.stopPropergation</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293> 假設我點擊一個按鈕得到事件e,我把事件e綁定到變數上面,過一秒後打印這個變數,請問打印出什麼? </p><p data-v-97bbe293> 空 , 因為 setTimeout 他是一個 異步事件, 他等同步執行完再執行, 這時他那個變量 e 不存在了 </p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>事件委託是什麼?</p><p data-v-97bbe293>假設有父子元素, 監聽子元素事件</p><br data-v-97bbe293><p data-v-97bbe293>假設ul裡面有很多li, 然後要求點擊li觸發一個事件</p><br data-v-97bbe293><p data-v-97bbe293>假如在每個li都綁定事件 會增大代碼量和內存</p><br data-v-97bbe293><p data-v-97bbe293> 可以根據事件冒泡在list item上面觸發的事件會向上冒泡到父元素 ul 上面 </p><br data-v-97bbe293><p data-v-97bbe293>所以可以在 ul 上面監聽</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>事件委託優點?</p><p data-v-97bbe293>可以減少代碼量, 減少內存, 動態綁定</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>事件委託缺點?</p><p data-v-97bbe293> 用了之後在開發者工具看他的事件綁定會發現沒有, 會不知道誰在監聽這個元素 </p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs018" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ 深淺拷貝? </div><p data-v-97bbe293>深淺拷貝區別</p><p data-v-97bbe293>淺拷貝 只會複製 最外面 那一層屬性</p><br data-v-97bbe293><p data-v-97bbe293>簡單物件還可以 , 裡面又有物件時 ...&gt; 多層次嵌套 時 有問題</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293># 淺拷貝</p><p data-v-97bbe293>1 ...展開運算符</p><p data-v-97bbe293>const o = { ...obj }</p><p data-v-97bbe293>console.log ( o )</p><br data-v-97bbe293><p data-v-97bbe293>2.</p><p data-v-97bbe293>const o= {}</p><p data-v-97bbe293> Object.assign( o,obj) <span class="comment" data-v-97bbe293> // (要拷貝的,被拷貝的)// (右 賦值 給 左) </span></p><p data-v-97bbe293>console.log ( o )</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293># 深拷貝</p><p data-v-97bbe293>深拷貝會複製物件的所有屬性和嵌套物件</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293># 3方法</p><p data-v-97bbe293>JSON.stringify()</p><br data-v-97bbe293><p class="pFou" data-v-97bbe293>const o = JSON.parse ( JSON.stringify ( obj ) )</p><br data-v-97bbe293><p data-v-97bbe293>lodash</p><br data-v-97bbe293><p class="pFou" data-v-97bbe293>const o = _.cloneDeep( obj )</p><br data-v-97bbe293><div class="bgcVS" data-v-97bbe293><p data-v-97bbe293>遞歸</p><div data-v-97bbe293><span class="function" data-v-97bbe293>function </span><span class="variable" data-v-97bbe293>deepCopy</span><span class="brackets" data-v-97bbe293>( </span><span class="word" data-v-97bbe293>newObj, oldObj </span><span class="brackets" data-v-97bbe293>){</span></div><div class="padTwo VSL" data-v-97bbe293><span class="comment" data-v-97bbe293>//把舊的值取出來給新的值</span><div data-v-97bbe293></div><span class="comment" data-v-97bbe293>//先遍歷舊的 , 注意 k 是誰</span></div><div class="padTwo VSL" data-v-97bbe293><span class="then" data-v-97bbe293>for </span> <span class="brackets" data-v-97bbe293>(</span><span class="function" data-v-97bbe293>let </span> <span class="word" data-v-97bbe293>k </span><span class="function" data-v-97bbe293>in </span><span class="word" data-v-97bbe293>oldObj </span><span class="brackets" data-v-97bbe293>){</span><div class="padTwo VSL" data-v-97bbe293><div data-v-97bbe293><span class="comment" data-v-97bbe293>// 處理數組問題</span></div><div data-v-97bbe293><span class="comment" data-v-97bbe293>// 通過值來判斷</span></div><div data-v-97bbe293><span class="then" data-v-97bbe293>if</span><span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>oldObj</span><span class="brackets" data-v-97bbe293>[</span> <span class="word" data-v-97bbe293>k </span><span class="brackets" data-v-97bbe293>] </span><span class="word" data-v-97bbe293>intanceof </span><span class="brackets" data-v-97bbe293>Array</span><span class="brackets" data-v-97bbe293>) { </span><span class="comment" data-v-97bbe293>// oldObj [ k ] 屬性值</span></div><div class="padTwo VSL" data-v-97bbe293><div data-v-97bbe293><span class="comment" data-v-97bbe293>// 我要把hobby數組再次遍歷</span></div><div data-v-97bbe293><span class="comment" data-v-97bbe293>// 我要把跑步拿出來放到新物件hobby第1個參數</span></div><div data-v-97bbe293><span class="comment" data-v-97bbe293>// 我要把足球拿出來放到新物件hobby第2個參數</span></div><div data-v-97bbe293><span class="word" data-v-97bbe293>newObj</span><span class="brackets" data-v-97bbe293>[ </span><span class="word" data-v-97bbe293>k </span><span class="brackets" data-v-97bbe293>]</span><span class="then" data-v-97bbe293>=</span><span class="brackets" data-v-97bbe293>[ ]</span><div data-v-97bbe293></div><div data-v-97bbe293><span class="comment" data-v-97bbe293>// newObj[k] 是 hobby</span></div><div data-v-97bbe293><span class="comment" data-v-97bbe293> // 新物件的 hobby 先給他一個空數組</span></div><div data-v-97bbe293><span class="comment" data-v-97bbe293>// 然後我在遍歷舊數組把他放進去</span></div><div data-v-97bbe293><span class="comment" data-v-97bbe293>// deepCopy(newObj[k],[&quot;跑步&quot;,&quot;足球&quot;])</span></div><div data-v-97bbe293><span class="variable" data-v-97bbe293>deepCopy</span><span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>newObj</span><span class="brackets" data-v-97bbe293>[</span><span class="word" data-v-97bbe293>k</span><span class="brackets" data-v-97bbe293>],</span><span class="word" data-v-97bbe293>oldObj</span><span class="brackets" data-v-97bbe293>[</span><span class="word" data-v-97bbe293>k</span><span class="brackets" data-v-97bbe293>])</span></div><div data-v-97bbe293><span class="comment" data-v-97bbe293>//調用自己遍歷數組時</span></div><div data-v-97bbe293><span class="comment" data-v-97bbe293>// K 變成數組的索引號了</span></div></div></div></div><div class="padTwo VSL" data-v-97bbe293><div data-v-97bbe293><span class="brackets" data-v-97bbe293>} </span><span class="then" data-v-97bbe293>else if</span><span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>oldObj</span><span class="brackets" data-v-97bbe293>[</span> <span class="word" data-v-97bbe293>k </span><span class="brackets" data-v-97bbe293>] </span><span class="word" data-v-97bbe293>intanceof </span><span class="brackets" data-v-97bbe293>Object</span><span class="brackets" data-v-97bbe293>) { </span><span class="comment" data-v-97bbe293>// oldObj [ k ] 屬性值</span></div><div class="padTwo VSL" data-v-97bbe293><div data-v-97bbe293><span class="word" data-v-97bbe293>newObj</span><span class="brackets" data-v-97bbe293>[ </span><span class="word" data-v-97bbe293>k </span><span class="brackets" data-v-97bbe293>]</span><span class="then" data-v-97bbe293>=</span><span class="brackets" data-v-97bbe293>{ }</span><div data-v-97bbe293><span class="variable" data-v-97bbe293>deepCopy</span><span class="brackets" data-v-97bbe293>(</span><span class="word" data-v-97bbe293>newObj</span><span class="brackets" data-v-97bbe293>[</span><span class="word" data-v-97bbe293>k</span><span class="brackets" data-v-97bbe293>],</span><span class="word" data-v-97bbe293>oldObj</span><span class="brackets" data-v-97bbe293>[</span><span class="word" data-v-97bbe293>k</span><span class="brackets" data-v-97bbe293>])</span></div></div></div></div><div class="padTwo VSL" data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span><span class="then" data-v-97bbe293>else </span><span class="brackets" data-v-97bbe293>{</span><div data-v-97bbe293><div data-v-97bbe293><div class="padTwo VSL" data-v-97bbe293><span class="comment" data-v-97bbe293>// k 屬性名 oldObj[ k ] 屬性值</span></div><div class="padTwo VSL" data-v-97bbe293><span class="comment" data-v-97bbe293>// newObj[ k ] === o.uname</span><div data-v-97bbe293></div></div><div class="padTwo VSL" data-v-97bbe293><div data-v-97bbe293><span class="word" data-v-97bbe293>newObj</span><span class="brackets" data-v-97bbe293>[ </span><span class="word" data-v-97bbe293>k </span><span class="brackets" data-v-97bbe293>]</span><span class="then" data-v-97bbe293>= </span><span class="word" data-v-97bbe293>oldObj</span><span class="brackets" data-v-97bbe293>[ </span><span class="word" data-v-97bbe293>k </span><span class="brackets" data-v-97bbe293>]</span></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div></div></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div></div><div data-v-97bbe293><span class="brackets" data-v-97bbe293>}</span></div><br data-v-97bbe293><p data-v-97bbe293># 一定要 先數組 再物件</p><p data-v-97bbe293>因為 數組 屬於物件 他就把 數組當物件</p></div><p class="cor36" data-v-97bbe293> 遞歸怎麼分類呢?你怎麼知道他是基本類型?你怎麼知道它不是一個物件? </p><p data-v-97bbe293>用typeof</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>typeof返回什麼值,你認為它不是物件或者是物件呢?</p><p data-v-97bbe293>判定 typeof 是 object 就說明他肯定不是基本類型</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>如果它不是object有幾種情況?</p><p data-v-97bbe293>string number 布林 null function(返回function)</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>假設你知道哪些是物件,那些不是物件,接下來怎麼區分?</p><p data-v-97bbe293>在物件裡面區分看他是不是函數,再看它是普通函數還是箭頭函數</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>普通函數還是箭頭函數怎麼看?</p><p data-v-97bbe293>看他有沒有prototype,箭頭函數沒有prototype</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293> 你知道他們區別後接下來做什麼?如果它是普通函數要怎麼複製它? </p><p data-v-97bbe293>所有參數傳給那個函數,然後返回它的返回值</p><br data-v-97bbe293><p data-v-97bbe293>: 直接用function然後return一個a.call然後地址,然後把參數弄下來</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>如果是箭頭函數要怎麼複製它?</p><p data-v-97bbe293>普通函數創建function 箭頭函數創建箭頭函數</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>.函數判斷完再來判斷什麼?</p><p data-v-97bbe293>看他是不是陣列</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>陣列判斷完再來判斷什麼?</p><p data-v-97bbe293>看他是不是Date</p><br data-v-97bbe293><p data-v-97bbe293>再來判斷什麼? 正則</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>要著重檢測的類型有哪些?</p><p data-v-97bbe293>物件 日期 函數 字串 正則表達式</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>先檢查她是對象還是陣列呢?</p><p data-v-97bbe293>先檢查陣列</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>對JSON的理解?</p><p data-v-97bbe293>是一門表示通用數據結構的語言</p><br data-v-97bbe293><p data-v-97bbe293>用來代替XML用來做數據交換</p><br data-v-97bbe293><p data-v-97bbe293>JSON可以表示物件 數組 不林 string number</p><br data-v-97bbe293><p data-v-97bbe293>一般在 AJAX 得到的請求就是 JSON</p><br data-v-97bbe293><br data-v-97bbe293><p id="onejs019" class="cor36" data-v-97bbe293>什麼是 RESTful API</p><p data-v-97bbe293>RESTful API (表示性狀態轉移接口) 是一種設計風格</p><br data-v-97bbe293><p data-v-97bbe293>API 設計規範</p><br data-v-97bbe293><p data-v-97bbe293>1. 將一切數據視作資源</p><br data-v-97bbe293><p data-v-97bbe293>2. 利用 HTTP 請求方式 , 描述對資源的操作 ( 增 刪 改 查 )</p><br data-v-97bbe293><p data-v-97bbe293>3. 通過 HTTP 響應狀態碼 , 描述對資源的 操作結果</p><br data-v-97bbe293><p data-v-97bbe293>就是通過 URL 就知道要什麼資源 ,</p><br data-v-97bbe293><p data-v-97bbe293>通過 HTTP method 就知道要做什麼,</p><br data-v-97bbe293><p data-v-97bbe293>通過 HTTP status code 就知道結果如何</p><br data-v-97bbe293><p data-v-97bbe293>比如</p><br data-v-97bbe293><p data-v-97bbe293>GET 代表獲取一個資源</p><br data-v-97bbe293><p data-v-97bbe293>POST 代表添加一個資源</p><br data-v-97bbe293><p data-v-97bbe293>PUT 代表修改一個資源</p><br data-v-97bbe293><p data-v-97bbe293>DELETE 代表刪除一個資源</p><br data-v-97bbe293><p data-v-97bbe293> 用 HTTP Status Code 傳遞 server 的狀態訊息 ,ex 200 表示成功 , 500 表示 server 內部錯誤 </p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>用 Rest 的優勢?</p><p data-v-97bbe293>1. 風格統一 , 不會出現各種命名的代碼</p><br data-v-97bbe293><p data-v-97bbe293>2. 面相資源 , 一目了然 , 有自解釋性</p><br data-v-97bbe293><p data-v-97bbe293>3. 充分利用 HTTP 協議本身語意</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>併發和併行?</p><p data-v-97bbe293> 併發是宏觀概念,表示並行發生, 並行是微觀概念, 表示cpu有多個核心同時執行兩個任務 </p><br data-v-97bbe293><p data-v-97bbe293>並行是微觀概念, 表示cpu有多個核心同時執行兩個任務</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>JS異步編程實現方式?</p><p data-v-97bbe293>回調函數 . promise . async和await</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>AJAX有2種方法,XMLHttpRequest和fetch,他們的優缺點?</p><p data-v-97bbe293>XHR大多數用他的庫axios</p><br data-v-97bbe293><p data-v-97bbe293> Fetch優勢在於瀏覽器原生支持, 方便去用, 他的API也比xhr使用起來簡單 </p><br data-v-97bbe293><br data-v-97bbe293><div id="onejs020" class="articleCardTitle cor36" data-v-97bbe293> [ JS ] ≫ promise 的狀態? </div><p data-v-97bbe293>pending 待定: 初始狀態</p><br data-v-97bbe293><p data-v-97bbe293>fullfilled 兌現: 操作成功</p><br data-v-97bbe293><p data-v-97bbe293>rejected 拒絕: 操作失敗</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>Promise 狀態 一但 兌現 / 拒絕 就 無法再改變</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>promise解決了什麼問題?</p><p data-v-97bbe293>解決回調地獄</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>promise成功失敗的回調放哪?</p><p data-v-97bbe293>.then</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>catch是幹嘛的?</p><p data-v-97bbe293>捕獲promise的錯誤</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>finally?</p><p data-v-97bbe293>不論成功 (.then) 失敗 (.catch) 都會調用的方法</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>promise的缺點?</p><p data-v-97bbe293>一旦執行promise沒辦法取消, 它裡面的錯誤只能用回調函數來捕獲</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>Promise.all?</p><p data-v-97bbe293> 傳入多個promise而這些promise都是成功的話 Promise.all就執行相對應函數 </p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>Promise.race?</p><p data-v-97bbe293>傳入多個promise而只要一個成功或失敗, 就返回那個</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>promise的缺點?</p><p data-v-97bbe293>一旦執行promise沒辦法取消, 它裡面的錯誤只能用回調函數來捕獲</p><p data-v-97bbe293>就整個都失敗</p><br data-v-97bbe293><p data-v-97bbe293>Promise.all如果失敗了一個會不會執行失敗的回調? _ 會</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>那是第一個失敗時執行還是所有都失敗在執行?</p><p data-v-97bbe293>只要第一個失敗就執行,並以這個失敗的結果來執行下面的回調</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>Promise是一個類還是函數呢?</p><p data-v-97bbe293> 它可以是函數, 你把它做為單獨的函數的話要自己實現原型, 用類的話, 直接把它方法寫到類的定義上就好 </p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>這個Promise接收什麼參數呢?</p><p data-v-97bbe293>它是一個回調函數</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>這個回調函數接收什麼參數呢?</p><p data-v-97bbe293>resolve 和 reject</p><br data-v-97bbe293><p data-v-97bbe293> Promise接受到這個參數後,它對這個函數要立即執行嗎?還是異步執行? _ 立即執行 </p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>Promise執行完這個函數後要返回什麼值?</p><p data-v-97bbe293> 物件,這個物件至少有一個than方法, 可能還會有catch跟finaly方法, 在then裡面可以添加更多的回調 </p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293> 一般promise後面.then,這個.then的參數和返回值是什麼? </p><p data-v-97bbe293> then的參數第一個是成功的回調, 第二個參數是錯誤的回調, 然後返回一個promise </p><br data-v-97bbe293><p data-v-97bbe293>那返回的這個promise是之前的promise嗎? _ 是</p><br data-v-97bbe293><p class="cor36" data-v-97bbe293>Promise.all怎麼自己去模擬?</p><p data-v-97bbe293> 就是發三個請求,三個請求成功了,就調用成功,任何一個失敗了就調用失敗 </p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293> 不用Promise.all怎麼做? _ (可不可以給2分鐘考慮思路,promise4步) </p><p data-v-97bbe293> 先記promise.all的用法, 他會接收陣列參數, 第一步把所有promise封裝到陣列裡面, 陣列能做遍歷, 裡面寫成功函數和失敗函數, 如果成功成功數目加一or給結果陣列裡面的結果填充, 比如第一個promise成功了, 給結果第一項變成他的data, 第二個..., 怎麼才能繼續, 變了data後看一下是不是三項都是data或成功, 那就可以繼續了, 最終要確定是否成功就是我這次成功之後看一下這個陣列是否是全成功的, 如果不是就什麼都不做, 最後成功的那個請求就負責往下走, 而失敗就直接調用失敗不用數數 </p><br data-v-97bbe293><br data-v-97bbe293><p id="onejs021" class="cor36" data-v-97bbe293>async/await怎麼用?</p><p data-v-97bbe293>比如在AJAX請求之間, 先聲明一個async function</p><br data-v-97bbe293><p data-v-97bbe293>把這個AJAX請求寫在await後面,</p><br data-v-97bbe293><p data-v-97bbe293>因為這個async本身是一個函數包裹了不同的異步請求的任務,</p><br data-v-97bbe293><p data-v-97bbe293>然後它碰到這個await就會執行這個異步函數返回一個promise</p><br data-v-97bbe293><p data-v-97bbe293>但不確定這個promis會返回正確還是錯誤</p><br data-v-97bbe293><p data-v-97bbe293>所以可以用try catch來捕捉這個異常</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293> 假如我有f1f2都返回promise如果我想await要等待兩個異步操作結束之後再console.log(z)? </p><p data-v-97bbe293> 可以用promise.all, peomise.all可以將多個promise合成一個新的promise, 當兩個promise都是成功的狀態下, 就是它返回一個結果陣列, 如果是失敗的話它會將, 首先哪個錯的promise的狀態的結果返回出來 </p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293> 如果我想用await依次執行f1f2呢?就是等f1執行完我再去執行f2? </p><p data-v-97bbe293>.await(f1).await(f2)</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>await永遠異步對不對? _ 對</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>await後面一般接promise對不對? _ 對</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>如果不接promise會怎樣?await 1會怎樣?</p><p data-v-97bbe293>它會默認返回一個promise, 它會把它封裝成promise.resolve 1</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>const a = 1 和 const a = await 1一樣嗎?</p><p data-v-97bbe293>不一樣, 有await會變異步</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>a = await 1相當於a = 1嗎?</p><p data-v-97bbe293>不是</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293> (await是語法糖,await所有寫法會變成promise,不是promise也強行變成promise) </p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>await我們在之後接上一個異步請求,a = await ajax()?</p><p data-v-97bbe293>那要等到promise結果返回,在執行a = await ajax()</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>怎麼捕獲await中的錯誤?</p><p data-v-97bbe293>用 try , catch</p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>node.js什麼是EventLoop?</p><p data-v-97bbe293>Node.js將任務分成幾個大類</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>有timers階段</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>還有IO</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>callbacks階段</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>還有prepare階段</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>還有poll輪詢階段</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>還有check階段</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>還有close callbcak階段</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>一般在三個階段停留時間比較長 timers poll check</p><br data-v-97bbe293><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>setTimeout哪個階段阿? timers</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293> 那promise的then回調在哪個階段執行? 跟nextTick一樣, 現階段結束之前執行 </p><br data-v-97bbe293><br data-v-97bbe293><br data-v-97bbe293><p id="onejs022" class="cor36" data-v-97bbe293>JS的事件循環?</p><p data-v-97bbe293>打開瀏覽器頁面時, 瀏覽器會開闢隊列,</p><br data-v-97bbe293><p data-v-97bbe293>然後隊列分為 微任務隊列 宏任務隊列,</p><br data-v-97bbe293><p data-v-97bbe293>在執行script代碼時, 會把同步代碼之外的異步任務放到對列裡面去,</p><br data-v-97bbe293><p data-v-97bbe293> 在同步的代碼執行完成後, 去查看異步隊列中是否有滿足條件的執行任務, </p><br data-v-97bbe293><p data-v-97bbe293>然後把它取出來防到執行環境站裡面執行,</p><br data-v-97bbe293><p data-v-97bbe293>然後不斷循環這個過程, 這就是事件循環</p><br data-v-97bbe293><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>微任務和宏任務?</p><p data-v-97bbe293>微任務 宏任務 是nodejs說法,</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>瀏覽器只有 微任務 任務, 所以可以認為宏任務就是任務</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293> 任務是最常規的東西, 你引入script標籤 寫一個setTimeout, 它的回調或代碼裡面都是任務, </p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293> 這個任務裡面你可以不停地去啟用微任務, 例如promise.then執行微任務 </p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>那些函數是微任務和那些是宏任務?</p><p data-v-97bbe293> setTimeout宏任務 promise裡面then微任務 async函數裡面await後面的部分微任務 </p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>微任務和宏任務執行順序? _ 宏任務先執行</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>一般第一個任務是什麼任務?(宏任務裡可以插入微任務) _ 宏任務</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>在頁面中引入一個script標籤,那這個script是什麼任務? _ 宏任務</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293> 我在兩個宏任務之間執行一個微任務,那肯定微任務在兩個中間執行隊嗎? _ 對 </p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293> 那我在中間這個微任務裡面再次執行一個微任務,它會插在下一個宏任務執行之前執行嗎?(題目問可不可以插宏任務) _ 會 </p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293> 假設我在兩個宏任務之間已經安排了兩個微任務,然後在第一個微任務執行結束的時候,又插入一個新的微任務,這個新的微任務可以在下一個微任務執行之前執行嗎? </p><p data-v-97bbe293>(題目問可不可以插微任務)</p><br data-v-97bbe293><p data-v-97bbe293> 不行, 微任務要排隊, 微任務只能插在宏任務之前 不能, . . . 兩個微任務之間不能插微任務 </p><br data-v-97bbe293><br data-v-97bbe293><p class="cor36" data-v-97bbe293>假設一個宏任務觸發一個微任務和宏任務,先執行哪個?</p><p data-v-97bbe293>微任務之後的微任務也是會繼續執行微任務, 直到微任務隊列空</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293>Promise.then(f1)這個then後面接的f1是異步還是同步? _ 異步</p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293> 第一行Promise.then(f1)第二console.log(999),f1會在999之後執行對嗎? _ 對 </p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293> 第一行Promise.then(f1)第二setTimeout(999),f1和999哪個先執行? _ f1 </p><br data-v-97bbe293><br data-v-97bbe293><p data-v-97bbe293> 為什麼then回調可以比setTimeout先執行? _ then屬於微任務, setTimeout屬於宏任務 </p><br data-v-97bbe293><br data-v-97bbe293>',736),R=t(()=>b("div",{class:"toTopButton"},[b("div",{class:"disCen"},"___"),b("div",{class:"disCen"},"▲")],-1)),D=[R],X=t(()=>b("div",{class:"toBotButton"},[b("div",{class:"disCen"},"▼"),b("div",{class:"disCen"},"￣")],-1)),G=[X],U=t(()=>b("div",{class:"timeDiv"},null,-1)),z={__name:"JsPageOne",setup(d){const p=f(!1);window.addEventListener("scroll",function(){p.value=window.scrollY>0});function u(){window.scrollTo({top:0,left:0,behavior:"smooth"})}function m(){window.scrollTo({top:999999,left:0,behavior:"smooth"})}function s(c){window.scrollTo({top:document.getElementById(`${c}`).offsetTop,behavior:"smooth"})}return(c,a)=>{const w=k("dir");return T(),j(h,null,[b("section",null,[b("div",C,[b("div",N,[b("div",x,[O,b("div",{onClick:a[0]||(a[0]=e=>s("onejs001")),class:"leftNavText"},"JS數據類型"),b("div",{onClick:a[1]||(a[1]=e=>s("onejs002")),class:"leftNavText"}," null undefined "),b("div",{onClick:a[2]||(a[2]=e=>s("onejs003")),class:"leftNavText"},"==&==="),b("div",{onClick:a[3]||(a[3]=e=>s("onejs004")),class:"leftNavText"},"0.1+0.2"),b("div",{onClick:a[4]||(a[4]=e=>s("onejs027")),class:"leftNavText"}," 判斷數字是小數 "),b("div",{onClick:a[5]||(a[5]=e=>s("onejs028")),class:"leftNavText"},"數組去重"),b("div",{onClick:a[6]||(a[6]=e=>s("onejs024")),class:"leftNavText"}," 判斷變量是否為陣列 "),b("div",{onClick:a[7]||(a[7]=e=>s("onejs026")),class:"leftNavText"}," 獲得陣列最後一項 "),b("div",{onClick:a[8]||(a[8]=e=>s("onejs030")),class:"leftNavText"},"數組清空"),b("div",{onClick:a[9]||(a[9]=e=>s("onejs023")),class:"leftNavText"}," 判斷一個物件為空 "),b("div",{onClick:a[10]||(a[10]=e=>s("onejs025")),class:"leftNavText"}," 判斷一個物件是否有某屬性 "),b("div",{onClick:a[11]||(a[11]=e=>s("onejs029")),class:"leftNavText"},"合併 2 物件"),b("div",{onClick:a[12]||(a[12]=e=>s("onejs005")),class:"leftNavText"}," let var const "),b("div",{onClick:a[13]||(a[13]=e=>s("onejs006")),class:"leftNavText"},"展開運算符"),b("div",{onClick:a[14]||(a[14]=e=>s("onejs007")),class:"leftNavText"}," 遍歷數組有幾種方式 "),b("div",{onClick:a[15]||(a[15]=e=>s("onejs008")),class:"leftNavText"},"閉包"),b("div",{onClick:a[16]||(a[16]=e=>s("onejs009")),class:"leftNavText"}," 立即執行函數 "),b("div",{onClick:a[17]||(a[17]=e=>s("onejs010")),class:"leftNavText"},"this指向"),b("div",{onClick:a[18]||(a[18]=e=>s("onejs011")),class:"leftNavText"},"箭頭函數"),b("div",{onClick:a[19]||(a[19]=e=>s("onejs012")),class:"leftNavText"},"原型鏈"),b("div",{onClick:a[20]||(a[20]=e=>s("onejs013")),class:"leftNavText"},"new做了什麼"),b("div",{onClick:a[21]||(a[21]=e=>s("onejs014")),class:"leftNavText"},"繼承"),b("div",{onClick:a[22]||(a[22]=e=>s("onejs015")),class:"leftNavText"}," call apply bind "),b("div",{onClick:a[23]||(a[23]=e=>s("onejs016")),class:"leftNavText"},"防斗節流"),b("div",{onClick:a[24]||(a[24]=e=>s("onejs017")),class:"leftNavText"},"DOM"),b("div",{onClick:a[25]||(a[25]=e=>s("onejs018")),class:"leftNavText"}," 深拷貝淺拷貝 "),b("div",{onClick:a[26]||(a[26]=e=>s("onejs019")),class:"leftNavText"},"RESTful API"),b("div",{onClick:a[27]||(a[27]=e=>s("onejs020")),class:"leftNavText"},"promise狀態"),b("div",{onClick:a[28]||(a[28]=e=>s("onejs021")),class:"leftNavText"},"async/await"),b("div",{onClick:a[29]||(a[29]=e=>s("onejs022")),class:"leftNavText"},"JS事件循環"),b("div",{onClick:a[30]||(a[30]=e=>s("onejs0")),class:"leftNavText"}),b("div",{onClick:a[31]||(a[31]=e=>s("onejs0")),class:"leftNavText"}),b("div",{onClick:a[32]||(a[32]=e=>s("onejs0")),class:"leftNavText"}),b("div",{onClick:a[33]||(a[33]=e=>s("onejs0")),class:"leftNavText"})])])]),b("div",J,[b("div",L,[b("div",V,[P,b("div",$,[E,n(w,null,{default:r(()=>[_,A,g(),I,M,B]),_:1}),F]),H])])])]),b("div",null,[l(n(i,{name:"fade",tag:"div"},{default:r(()=>[b("div",{onClick:u,class:"toTop"},D)]),_:1},512),[[o,p.value]]),l(n(i,{name:"fade",tag:"div"},{default:r(()=>[b("div",{onClick:m,class:"toBot"},G)]),_:1},512),[[o,p.value]])]),U],64)}}},Q=q(z,[["__scopeId","data-v-97bbe293"]]);export{Q as default};
